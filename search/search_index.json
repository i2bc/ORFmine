{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Chris Papadopoulos 1 , Nicolas Chevrollier 2 , Hugo Arbes 1 , Anne Lopes 1 Affiliations 1 Universit\u00e9 Paris-Saclay, CEA, CNRS, Institute for Integrative Biology of the Cell (I2BC), 91198, Gif-sur-Yvette, France, anne.lopes@i2bc.paris-saclay.fr , cgpapado.bio@gmail.com , arbes.bioinfo@gmail.com . 2 Independent bio-informatician, Paris, France, nicolas.chevrollier@laposte.net . OMICS studies attribute a new role to the noncoding genome in the production of novel peptides. The widespread transcription of noncoding regions and the pervasive translation of the resulting RNAs offer a vast reservoir of novel peptides to the organisms. ORFmine[1][2] is an open-source package that aims at extracting, annotating, and characterizing the sequence and structural properties of all Open Reading Frames (ORFs) of a genome (including coding and noncoding sequences) along with their translation activity. ORFmine consists of several independent programs, ORFtrack , ORFold , ORFribo , and ORFdate , that can be used together or independently (see here for an example of application). ORFtrack searches for all possible ORFs longer than 60 nucleotides in the six frames of an input genome, and annotate them according to a set of genomic features (e.g. noncoding intergenic ORFs, coding ORFs, noncoding ORFs that overlap with a specific genomic feature...). It provides the user with a GFF file containing the annotations of all identified ORFs that can be directly uploaded on a genome viewer for a visual inspection. In addition, their amino acid and/or nucleotide sequences can be extracted in a FASTA file (for more details, see the complete documentation of ORFtrack). ORFold predicts the fold potential and the disorder and aggregation propensities of a set of amino acid sequences (all ORFs annotated by ORFtrack for example or any set of amino acid sequences provided with a FASTA file). The fold potential is estimated with the HCA method [3], while the disorder and aggregation propensities are calculated with IUPRred[4][4][6], and TANGO[7][8][9] respectively. The specificity of ORFold lies in the fact that the user can provide the amino acid sequences along with their corresponding annotations in a GFF file. In this case, ORFold produces new GFF files, each containing for each annotated sequence, their fold potential, disorder and aggregation propensities respectively, thereby enabling the manual inspection of these properties along a genome in a genome viewer (for more details, see the complete documentation of ORFold). ORFribo probes the translation activity of a set of ORFs of a genome based on Ribosome Profilng data (Ribo-Seq). ORFribo is very flexible and handles any type of ORFs once annotated in a GFF file (e.g. coding sequences, alternative ORFs (i.e., noncoding ORFs located in the alternative frames of CDSs) or intergenic ORFs). ORFribo has no a priori and does not predict any ORF status (translated or not for instance), but rather calculates for each ORF, the counts of reads that map on it along with the frame they are associated with (i.e., the frame of the ORF, or its two alternative frames), thereby providing information that can be indicative on the specificity of the translation of the ORF. The raw information is provided in a text table very easy to parse so that, the user is free to set its own thresholds (number of reads, specificity of translation (i.e. number of reads that are in the frame of the ORF)) to classify ORFs based on their translation signals and/or extract interesting candidates. In order to increase the read coverage of noncoding regions, expected to be low because they are usually associated with lower expression when expressed, ORFribo enables one to pool multiple Ribo-Seq datasets. Reads of good quality (quality thresholds are customizable by the user) of all datasets are thus merged together and the resulting signal is analyzed as a whole and provided as a single output table. The user is free to combine different datasets as he/she whishes (experiments performed in specific conditions, tissues etc). ORFdate estimates the evolutionary age (in Mya) of a set of ORFs of a genome (coding or noncoding ORFs) based on phylostratigraphy. References # Papadopoulos, C., Chevrollier, N., Lopes, A. Exploring the peptide potential of genomes. Meth. Mol. Biol. (2022). Papadopoulos, C., Arbes, H., Chevrollier, N., Blanchet, S., Cornu, D., Roginski, P., Rabier, C., Atia, S., Lespinet, O., Namy, O., Lopes, A. (submitted). Bitard-Feildel, T. & Callebaut, I. HCAtk and pyHCA: A Toolkit and Python API for the Hydrophobic Cluster Analysis of Protein Sequences. bioRxiv 249995 (2018). Dosztanyi, Z., Csizmok, V., Tompa, P. & Simon, I. The pairwise energy content estimated from amino acid composition discriminates between folded and intrinsically unstructured proteins. Journal of molecular biology 347, 827\u2013839 (2005). Doszta\u0301nyi, Z. Prediction of protein disorder based on IUPred. Protein Science 27, 331\u2013 340 (2018). Me\u0301sza\u0301ros, B., Erdo\u030bs, G. & Doszta\u0301nyi, Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46, W329\u2013W337 (2018). Fernandez-Escamilla, A.-M., Rousseau, F., Schymkowitz, J. & Serrano, L. Prediction of sequence-dependent and mutational effects on the aggregation of peptides and proteins. Nature biotechnology 22, 1302\u20131306 (2004). Linding, R., Schymkowitz, J., Rousseau, F., Diella, F. & Serrano, L. A comparative study of the relationship between protein structure and \u03b2-aggregation in globular and intrinsically disordered proteins. Journal of molecular biology 342, 345\u2013353 (2004). Rousseau, F., Schymkowitz, J. & Serrano, L. Protein aggregation and amyloidosis: confusion of the kinds? Current opinion in structural biology 16, 118\u2013126 (2006).","title":"Home"},{"location":"index.html#references","text":"Papadopoulos, C., Chevrollier, N., Lopes, A. Exploring the peptide potential of genomes. Meth. Mol. Biol. (2022). Papadopoulos, C., Arbes, H., Chevrollier, N., Blanchet, S., Cornu, D., Roginski, P., Rabier, C., Atia, S., Lespinet, O., Namy, O., Lopes, A. (submitted). Bitard-Feildel, T. & Callebaut, I. HCAtk and pyHCA: A Toolkit and Python API for the Hydrophobic Cluster Analysis of Protein Sequences. bioRxiv 249995 (2018). Dosztanyi, Z., Csizmok, V., Tompa, P. & Simon, I. The pairwise energy content estimated from amino acid composition discriminates between folded and intrinsically unstructured proteins. Journal of molecular biology 347, 827\u2013839 (2005). Doszta\u0301nyi, Z. Prediction of protein disorder based on IUPred. Protein Science 27, 331\u2013 340 (2018). Me\u0301sza\u0301ros, B., Erdo\u030bs, G. & Doszta\u0301nyi, Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46, W329\u2013W337 (2018). Fernandez-Escamilla, A.-M., Rousseau, F., Schymkowitz, J. & Serrano, L. Prediction of sequence-dependent and mutational effects on the aggregation of peptides and proteins. Nature biotechnology 22, 1302\u20131306 (2004). Linding, R., Schymkowitz, J., Rousseau, F., Diella, F. & Serrano, L. A comparative study of the relationship between protein structure and \u03b2-aggregation in globular and intrinsically disordered proteins. Journal of molecular biology 342, 345\u2013353 (2004). Rousseau, F., Schymkowitz, J. & Serrano, L. Protein aggregation and amyloidosis: confusion of the kinds? Current opinion in structural biology 16, 118\u2013126 (2006).","title":"References"},{"location":"How_it_works_orfdate.html","text":"How works ORFdate? # ORFdate attributes an age to the ORFs (coding or noncoding) of a species of interest (i.e. focal) by phylostratigraphy. The phylostratigraphy is established based on the focal species and a set of neighboring species defined by the user. An ORF (amino acid sequence) is presumed at least as old as the most recent ancestor between the focal species and the more distant species where a homolog of this ORF has been found. Each sequence is thus \"low-dated\" using the time of divergence (in fact the branch distance provided in the tree) between these two species. It assumes a rare horizontal gene transfer context (e.g. Eukaryotes) and is therefore not adapted to Prokaryotes. ORFdate generates a BLAST database from each fasta file of the focal neighboring sepcies and performs a BLASTp search with each ORF of the focal species as a query against these databases (neighbors). Considering only alignments that satisfy the defined evalue and minimum query coverage threshold (by default : evalue = 0.001; query_cov = 0.7), the program defines for each focal ORF its \"more distant hit\u201d as the more distant species with a significant alignment. Please note that the last node of the tree will be used as the upper limit for the age estimation. Consequently, all sequences with a match in the more distant species, with respect to the focal, are associated with the same upper bounded estimated age regardless of whether they may have other matches in more distant species outside the input tree. It outputs a three columns csv file with the focal ORFs, their more distant hit, and their diverging time with the focal species (if provided in the phylogenetic tree). More details can be found in Papadopoulos et al[1]. Papadopoulos, C., Arbes, H., Chevrollier, N., Blanchet, S., Cornu, D., Roginski, P., Rabier, C., Atia, S., Lespinet, O., Namy, O., Lopes, A. (submitted).","title":"How it works"},{"location":"How_it_works_orfdate.html#how-works-orfdate","text":"ORFdate attributes an age to the ORFs (coding or noncoding) of a species of interest (i.e. focal) by phylostratigraphy. The phylostratigraphy is established based on the focal species and a set of neighboring species defined by the user. An ORF (amino acid sequence) is presumed at least as old as the most recent ancestor between the focal species and the more distant species where a homolog of this ORF has been found. Each sequence is thus \"low-dated\" using the time of divergence (in fact the branch distance provided in the tree) between these two species. It assumes a rare horizontal gene transfer context (e.g. Eukaryotes) and is therefore not adapted to Prokaryotes. ORFdate generates a BLAST database from each fasta file of the focal neighboring sepcies and performs a BLASTp search with each ORF of the focal species as a query against these databases (neighbors). Considering only alignments that satisfy the defined evalue and minimum query coverage threshold (by default : evalue = 0.001; query_cov = 0.7), the program defines for each focal ORF its \"more distant hit\u201d as the more distant species with a significant alignment. Please note that the last node of the tree will be used as the upper limit for the age estimation. Consequently, all sequences with a match in the more distant species, with respect to the focal, are associated with the same upper bounded estimated age regardless of whether they may have other matches in more distant species outside the input tree. It outputs a three columns csv file with the focal ORFs, their more distant hit, and their diverging time with the focal species (if provided in the phylogenetic tree). More details can be found in Papadopoulos et al[1]. Papadopoulos, C., Arbes, H., Chevrollier, N., Blanchet, S., Cornu, D., Roginski, P., Rabier, C., Atia, S., Lespinet, O., Namy, O., Lopes, A. (submitted).","title":"How works ORFdate?"},{"location":"How_it_works_orfold.html","text":"How works ORFold? # ORFold is a tool developed in python3 which aims at characterizing the fold potential of a set of amino acid sequences with no knowledge of their 3D structures nor evolutionary information (orphan sequences can be treated). The fold potential of a sequence is calculated with the HCA method. Also, ORFold can estimate the disorder, and the aggregation propensities of the input sequences with IUPred and Tango respectively. Hydrophobic Clusters Analysis (HCA) # HCA [1] aims as delineating in an amino acid sequence, regions enriched in strong hydrophobic residues (HCA clusters) and regions of at least four consecutive non-hydrophobic residues (HCA linkers). The patterns of hydrophobic residues can be associated with specific regular secondary structures, and the distribution of the HCA clusters and linkers in a protein sequence can be used to estimate through the HCA score, its ability to fold (completely or partially). This score ranges from -10 to +10 with low HCA scores indicating sequences depleted in hydrophobic clusters and expected to be disordered in solution, while high HCA scores reflect sequences enriched in hydrophobic clusters and expected to generate aggregates in solution, though some of them could fold in lipidic environments. Foldable sequences are known to display an equilibrium between hydrophobic and hydrophilic residues (average of 33% of hydrophobic residues in globular proteins). They are mostly associated with intermediate HCA score values. The HCA score is calculated using the freely available software pyHCA which can be downloaded and installed following the instructions of its developers: https://github.com/T-B-F/pyHCA Tango # Tango [5][6][7] is a method which aims at predicting aggregation nucleating regions in protein sequences. If specified by the user, ORFold can calculate and add the aggregation propensity of a sequence in the output. Tango is not freely available software, and the user of ORFold should first contact the Tango developers to have access to the source code: http://tango.crg.es For the aggregation propensity estimation, according to the protocol proposed by Linding et al.[6], a sequence segment is considered as aggregation prone if it is composed of at least five consecutive residues predicted as populating a b-aggregated conformation with a percentage occupancy greater than 5%. Then, the aggregation propensity of each sequence is defined as the fraction of residues predicted in aggregation prone segments. IUPred # IUPred2A [2][3][4] is one of the best methods for the prediction of Intrinsically Disordered Proteins (IDPs) and can be used as a complement to the HCA score prediction. If specified by the user, ORFold can calculate and add the disorder propensity of a sequence in the output. IUPred is not freely available, and the user of ORFold should first contact the IUPred developers to have access to the source code : https://iupred2a.elte.hu For the disorder propensity estimation, in order to be consistent with the estimation of the aggregation propensity, ORFold searches for regions on the protein sequence that present at least five consecutive residues with a disorder probability higher than 0.5. The disorder propensity of each sequence is defined as the fraction of residues predicted as located in a highly disordered segment. References # Bitard-Feildel, T. & Callebaut, I. HCAtk and pyHCA: A Toolkit and Python API for the Hydrophobic Cluster Analysis of Protein Sequences. bioRxiv 249995 (2018). Dosztanyi, Z., Csizmok, V., Tompa, P. & Simon, I. The pairwise energy content estimated from amino acid composition discriminates between folded and intrinsically unstructured proteins. Journal of molecular biology 347, 827\u2013839 (2005). Doszta\u0301nyi, Z. Prediction of protein disorder based on IUPred. Protein Science 27, 331\u2013 340 (2018). Me\u0301sza\u0301ros, B., Erdo\u030bs, G. & Doszta\u0301nyi, Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46, W329\u2013W337 (2018). Fernandez-Escamilla, A.-M., Rousseau, F., Schymkowitz, J. & Serrano, L. Prediction of sequence-dependent and mutational effects on the aggregation of peptides and proteins. Nature biotechnology 22, 1302\u20131306 (2004). Linding, R., Schymkowitz, J., Rousseau, F., Diella, F. & Serrano, L. A comparative study of the relationship between protein structure and \u03b2-aggregation in globular and intrinsically disordered proteins. Journal of molecular biology 342, 345\u2013353 (2004). Rousseau, F., Schymkowitz, J. & Serrano, L. Protein aggregation and amyloidosis: confusion of the kinds? Current opinion in structural biology 16, 118\u2013126 (2006).","title":"How it works?"},{"location":"How_it_works_orfold.html#how-works-orfold","text":"ORFold is a tool developed in python3 which aims at characterizing the fold potential of a set of amino acid sequences with no knowledge of their 3D structures nor evolutionary information (orphan sequences can be treated). The fold potential of a sequence is calculated with the HCA method. Also, ORFold can estimate the disorder, and the aggregation propensities of the input sequences with IUPred and Tango respectively.","title":"How works ORFold?"},{"location":"How_it_works_orfold.html#hydrophobic-clusters-analysis-hca","text":"HCA [1] aims as delineating in an amino acid sequence, regions enriched in strong hydrophobic residues (HCA clusters) and regions of at least four consecutive non-hydrophobic residues (HCA linkers). The patterns of hydrophobic residues can be associated with specific regular secondary structures, and the distribution of the HCA clusters and linkers in a protein sequence can be used to estimate through the HCA score, its ability to fold (completely or partially). This score ranges from -10 to +10 with low HCA scores indicating sequences depleted in hydrophobic clusters and expected to be disordered in solution, while high HCA scores reflect sequences enriched in hydrophobic clusters and expected to generate aggregates in solution, though some of them could fold in lipidic environments. Foldable sequences are known to display an equilibrium between hydrophobic and hydrophilic residues (average of 33% of hydrophobic residues in globular proteins). They are mostly associated with intermediate HCA score values. The HCA score is calculated using the freely available software pyHCA which can be downloaded and installed following the instructions of its developers: https://github.com/T-B-F/pyHCA","title":"Hydrophobic Clusters Analysis (HCA)"},{"location":"How_it_works_orfold.html#tango","text":"Tango [5][6][7] is a method which aims at predicting aggregation nucleating regions in protein sequences. If specified by the user, ORFold can calculate and add the aggregation propensity of a sequence in the output. Tango is not freely available software, and the user of ORFold should first contact the Tango developers to have access to the source code: http://tango.crg.es For the aggregation propensity estimation, according to the protocol proposed by Linding et al.[6], a sequence segment is considered as aggregation prone if it is composed of at least five consecutive residues predicted as populating a b-aggregated conformation with a percentage occupancy greater than 5%. Then, the aggregation propensity of each sequence is defined as the fraction of residues predicted in aggregation prone segments.","title":"Tango"},{"location":"How_it_works_orfold.html#iupred","text":"IUPred2A [2][3][4] is one of the best methods for the prediction of Intrinsically Disordered Proteins (IDPs) and can be used as a complement to the HCA score prediction. If specified by the user, ORFold can calculate and add the disorder propensity of a sequence in the output. IUPred is not freely available, and the user of ORFold should first contact the IUPred developers to have access to the source code : https://iupred2a.elte.hu For the disorder propensity estimation, in order to be consistent with the estimation of the aggregation propensity, ORFold searches for regions on the protein sequence that present at least five consecutive residues with a disorder probability higher than 0.5. The disorder propensity of each sequence is defined as the fraction of residues predicted as located in a highly disordered segment.","title":"IUPred"},{"location":"How_it_works_orfold.html#references","text":"Bitard-Feildel, T. & Callebaut, I. HCAtk and pyHCA: A Toolkit and Python API for the Hydrophobic Cluster Analysis of Protein Sequences. bioRxiv 249995 (2018). Dosztanyi, Z., Csizmok, V., Tompa, P. & Simon, I. The pairwise energy content estimated from amino acid composition discriminates between folded and intrinsically unstructured proteins. Journal of molecular biology 347, 827\u2013839 (2005). Doszta\u0301nyi, Z. Prediction of protein disorder based on IUPred. Protein Science 27, 331\u2013 340 (2018). Me\u0301sza\u0301ros, B., Erdo\u030bs, G. & Doszta\u0301nyi, Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46, W329\u2013W337 (2018). Fernandez-Escamilla, A.-M., Rousseau, F., Schymkowitz, J. & Serrano, L. Prediction of sequence-dependent and mutational effects on the aggregation of peptides and proteins. Nature biotechnology 22, 1302\u20131306 (2004). Linding, R., Schymkowitz, J., Rousseau, F., Diella, F. & Serrano, L. A comparative study of the relationship between protein structure and \u03b2-aggregation in globular and intrinsically disordered proteins. Journal of molecular biology 342, 345\u2013353 (2004). Rousseau, F., Schymkowitz, J. & Serrano, L. Protein aggregation and amyloidosis: confusion of the kinds? Current opinion in structural biology 16, 118\u2013126 (2006).","title":"References"},{"location":"How_it_works_orfribo.html","text":"How works ORFribo? # ORFribo is designed to analyse, based on ribosome-profiling data, the translation activity of all the ORFs of a genome (coding and noncoding) that are annotated in a gff file. We strongly recommend using ORFtrack to generate the gff file since ORFtrack and ORFribo were jointly developed so that the output of ORFtrack fits the prerequisites of ORFribo. However, the user might provide its own gff. In this case, each ORF annotated in the input gff file must be associated with the name of its corresponding ORF category that can be different from those defined by ORFtrack (e.g. intergenic, ALT-ORF, foldable, xyz...). The ORF category must be indicated in the 3rd column of the input gff file and in the \"final_counts\" attribute of the config.yaml file so that ORFribo knows which ORF category is to be analyzed (more details in the dedicated section - an example of the gff output generated by ORFtrack can be found in the ORFmine/examples/database directory and may be used as guide to prepare your own gff). The three main steps of ORFribo are: Step 1: Determination of the P-site offset: For each read size or kmer, ORFribo tries to find the distance in nucleotides from the 5'-end of the read (begining of the Ribosome Protected Fragment - RPF) to the first base of the ribosome's P-site, thanks to riboWaltz [1]. The detection of the first base of the ribosome's P-site enables the identification of the translated codon and, thus, of the translated frame. This is necessary to get the quality controls about phasing in coding regions. Step 2: Detection of kmers of good quality and filtering of low quality ones: Read phasing is a very important step to make sure we are able to detect the frame that is translated among the three frames of the RNA. In coding regions, the frame that is expected to be translated (i.e. the coding one) is already known and will be used to estimate the quality of the experiment and more precisely, to identify read sizes (i.e. kmers) of good quality. To do so, ORFribo will calculate for all kmers mapping on CDS coordinates, the fraction of kmers that indeed map on the coding frame of the CDSs (i.e. named P0 or FO frame). ORFribo will then retain for the analysis (Step 3), only kmers whose P-site position as predicted by riboWaltz indicates, for more than 70% of the corresponding kmers, codons that belong to the P0/F0 coding frame of the CDSs. 70% is the default value but it can be modified by the user through the config.yaml file. Step 3: Analysis: alignment on all ORFs of interest: Read kmers which have passed the phasing filter on CDSs are aligned on the set of ORFs indicated by the user (e.g. intergenic ORFs, alternative ORFs...). The ORF categories to be analyzed by ORFribo must correspond to those identified by ORFtrack and provided in the 3rd column of its gff output (see an example examples/database/mapping_orf_Scer.gff) (see here for more details on the ORF categories and annotation process). If another gff file is provided, please have a look on the format of the ORFtrack gff output. The P-site offset detected for each kmer in the previous step allows to determine the proportion of reads in each phase of every tested ORF, thereby estimating its fractions of in-frame reads (F0 or P0), and in its +1 and +2 frames (F1 and F2 respectively). This can help the user identify ORFs with high levels of translation specificity (high fractions of F0 reads) or classify ORFs according to their levels of translation specificity (i.e. different levels of F0 reads). More details on the complete pipeline of ORFribo can be found in the Figure S1 of Papadopoulos et al [2]. References # Lauria F, Tebaldi T, Bernab\u00f2 P, Groen EJN, Gillingwater TH, Viero G. riboWaltz: Optimization of ribosome P-site positioning in ribosome profiling data. PLoS Comput Biol. 2018 Aug 13;14(8):e1006169. Papadopoulos, C., Arbes, H., Chevrollier, N., Blanchet, S., Cornu, D., Roginski, P., Rabier, C., Atia, S., Lespinet, O., Namy, O., Lopes, A. (submitted).","title":"How it works"},{"location":"How_it_works_orfribo.html#how-works-orfribo","text":"ORFribo is designed to analyse, based on ribosome-profiling data, the translation activity of all the ORFs of a genome (coding and noncoding) that are annotated in a gff file. We strongly recommend using ORFtrack to generate the gff file since ORFtrack and ORFribo were jointly developed so that the output of ORFtrack fits the prerequisites of ORFribo. However, the user might provide its own gff. In this case, each ORF annotated in the input gff file must be associated with the name of its corresponding ORF category that can be different from those defined by ORFtrack (e.g. intergenic, ALT-ORF, foldable, xyz...). The ORF category must be indicated in the 3rd column of the input gff file and in the \"final_counts\" attribute of the config.yaml file so that ORFribo knows which ORF category is to be analyzed (more details in the dedicated section - an example of the gff output generated by ORFtrack can be found in the ORFmine/examples/database directory and may be used as guide to prepare your own gff). The three main steps of ORFribo are: Step 1: Determination of the P-site offset: For each read size or kmer, ORFribo tries to find the distance in nucleotides from the 5'-end of the read (begining of the Ribosome Protected Fragment - RPF) to the first base of the ribosome's P-site, thanks to riboWaltz [1]. The detection of the first base of the ribosome's P-site enables the identification of the translated codon and, thus, of the translated frame. This is necessary to get the quality controls about phasing in coding regions. Step 2: Detection of kmers of good quality and filtering of low quality ones: Read phasing is a very important step to make sure we are able to detect the frame that is translated among the three frames of the RNA. In coding regions, the frame that is expected to be translated (i.e. the coding one) is already known and will be used to estimate the quality of the experiment and more precisely, to identify read sizes (i.e. kmers) of good quality. To do so, ORFribo will calculate for all kmers mapping on CDS coordinates, the fraction of kmers that indeed map on the coding frame of the CDSs (i.e. named P0 or FO frame). ORFribo will then retain for the analysis (Step 3), only kmers whose P-site position as predicted by riboWaltz indicates, for more than 70% of the corresponding kmers, codons that belong to the P0/F0 coding frame of the CDSs. 70% is the default value but it can be modified by the user through the config.yaml file. Step 3: Analysis: alignment on all ORFs of interest: Read kmers which have passed the phasing filter on CDSs are aligned on the set of ORFs indicated by the user (e.g. intergenic ORFs, alternative ORFs...). The ORF categories to be analyzed by ORFribo must correspond to those identified by ORFtrack and provided in the 3rd column of its gff output (see an example examples/database/mapping_orf_Scer.gff) (see here for more details on the ORF categories and annotation process). If another gff file is provided, please have a look on the format of the ORFtrack gff output. The P-site offset detected for each kmer in the previous step allows to determine the proportion of reads in each phase of every tested ORF, thereby estimating its fractions of in-frame reads (F0 or P0), and in its +1 and +2 frames (F1 and F2 respectively). This can help the user identify ORFs with high levels of translation specificity (high fractions of F0 reads) or classify ORFs according to their levels of translation specificity (i.e. different levels of F0 reads). More details on the complete pipeline of ORFribo can be found in the Figure S1 of Papadopoulos et al [2].","title":"How works ORFribo?"},{"location":"How_it_works_orfribo.html#references","text":"Lauria F, Tebaldi T, Bernab\u00f2 P, Groen EJN, Gillingwater TH, Viero G. riboWaltz: Optimization of ribosome P-site positioning in ribosome profiling data. PLoS Comput Biol. 2018 Aug 13;14(8):e1006169. Papadopoulos, C., Arbes, H., Chevrollier, N., Blanchet, S., Cornu, D., Roginski, P., Rabier, C., Atia, S., Lespinet, O., Namy, O., Lopes, A. (submitted).","title":"References"},{"location":"Input_orfold.html","text":"Running ORFold: # Inputs # Basically, ORFold requires only a FASTA file containing the amino acid sequences to treat (given with the -fna label). ORFold can handle several FASTA files at the same time. In this case, it will treat them independently and will generate as many outputs as entered FASTA files. FASTA file example: >aminoacid_sequence_1 AGNVCFGGRTYMPDFDGMSCVNWQERT >aminoacid_sequence_2 MPDFMPCNVSDRTEEEPMSPARTYDFGHKLCVSDFTPMLKKPERT How to estimate the fold potential and/or disorder and aggregation propensities # By default, ORFold only estimates the fold potential of the input sequences. The disorder and aggregation propensities can be however calculated as well. The user can specify which calculation methods are to be launched with the -options argument. Each method used by ORFold is referred by its initial: HCA : H IUPred : I TANGO : T The user must specify the combination of methods he wants to apply on the input sequences giving their initials with the -options argument without any space: -options HIT for running the 3 programs or -options HT if the user wants to run only HCA and Tango for example. The order of the letters has no importance, -options HIT and -options THI will lead to the same result. Basic run # The following instruction estimates the fold potential, and the disorder and aggregation propensities of all amino acid sequences contained in the input fASTA file: orfold -fna sequences.fasta -options HIT The user has to notice that IUPred and Tango provide additional information to HCA but will slow down considerably ORFold for large datasets. The next instruction only calculate the fold potential with HCA: orfold -fna sequences.fasta -options H Output: # ORFold produces a table (fasta_rootname.tab) that contains for each input sequence, the computed values (separated by tabulations) according to the user request (fold potential, and/or disorder and/or aggregation propensities). Output file example with -options HIT (fold potential, disorder and aggregation propensities estimated from HCA, IUPred and Tango, see here for more details): Seq_ID HCA Disord Aggreg aminoacid_sequence_1 1.340 0.000 0.230 aminoacid_sequence_2 -0.230 0.120 0.012 Output file example with -options H (fold potential estimated with HCA, see here for more details): Seq_ID HCA Disord Aggreg aminoacid_sequence_1 1.340 nan nan aminoacid_sequence_2 -0.230 nan nan","title":"Input orfold"},{"location":"Input_orfold.html#running-orfold","text":"","title":"Running ORFold:"},{"location":"Input_orfold.html#inputs","text":"Basically, ORFold requires only a FASTA file containing the amino acid sequences to treat (given with the -fna label). ORFold can handle several FASTA files at the same time. In this case, it will treat them independently and will generate as many outputs as entered FASTA files. FASTA file example: >aminoacid_sequence_1 AGNVCFGGRTYMPDFDGMSCVNWQERT >aminoacid_sequence_2 MPDFMPCNVSDRTEEEPMSPARTYDFGHKLCVSDFTPMLKKPERT","title":"Inputs"},{"location":"Input_orfold.html#how-to-estimate-the-fold-potential-andor-disorder-and-aggregation-propensities","text":"By default, ORFold only estimates the fold potential of the input sequences. The disorder and aggregation propensities can be however calculated as well. The user can specify which calculation methods are to be launched with the -options argument. Each method used by ORFold is referred by its initial: HCA : H IUPred : I TANGO : T The user must specify the combination of methods he wants to apply on the input sequences giving their initials with the -options argument without any space: -options HIT for running the 3 programs or -options HT if the user wants to run only HCA and Tango for example. The order of the letters has no importance, -options HIT and -options THI will lead to the same result.","title":"How to estimate the fold potential and/or disorder and aggregation propensities"},{"location":"Input_orfold.html#basic-run","text":"The following instruction estimates the fold potential, and the disorder and aggregation propensities of all amino acid sequences contained in the input fASTA file: orfold -fna sequences.fasta -options HIT The user has to notice that IUPred and Tango provide additional information to HCA but will slow down considerably ORFold for large datasets. The next instruction only calculate the fold potential with HCA: orfold -fna sequences.fasta -options H","title":"Basic run"},{"location":"Input_orfold.html#output","text":"ORFold produces a table (fasta_rootname.tab) that contains for each input sequence, the computed values (separated by tabulations) according to the user request (fold potential, and/or disorder and/or aggregation propensities). Output file example with -options HIT (fold potential, disorder and aggregation propensities estimated from HCA, IUPred and Tango, see here for more details): Seq_ID HCA Disord Aggreg aminoacid_sequence_1 1.340 0.000 0.230 aminoacid_sequence_2 -0.230 0.120 0.012 Output file example with -options H (fold potential estimated with HCA, see here for more details): Seq_ID HCA Disord Aggreg aminoacid_sequence_1 1.340 nan nan aminoacid_sequence_2 -0.230 nan nan","title":"Output:"},{"location":"Objective_orfold.html","text":"Aims and general description of ORFold # ORFold aims at estimating the fold potential of a set of amino acid sequences using the Hydrophobic Clusters Analysis (HCA) method [1]. We define the foldability of an amino acid sequence as its ability to fold to a stable 3D structure or to a molten globule state in which the specific tertiary structure is lost whereas the secondary structures are intact. ORFold calculates the HCA foldability score of each given sequence. Furthermore, ORFold can estimate the disorder and/or aggregation propensities of the input sequences using the IUPred[2][3][4] and Tango[5][6][7] methods respectively. References # Bitard-Feildel, T. & Callebaut, I. HCAtk and pyHCA: A Toolkit and Python API for the Hydrophobic Cluster Analysis of Protein Sequences. bioRxiv 249995 (2018). Dosztanyi, Z., Csizmok, V., Tompa, P. & Simon, I. The pairwise energy content estimated from amino acid composition discriminates between folded and intrinsically unstructured proteins. Journal of molecular biology 347, 827\u2013839 (2005). Doszta\u0301nyi, Z. Prediction of protein disorder based on IUPred. Protein Science 27, 331\u2013 340 (2018). Me\u0301sza\u0301ros, B., Erdo\u030bs, G. & Doszta\u0301nyi, Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46, W329\u2013W337 (2018). Fernandez-Escamilla, A.-M., Rousseau, F., Schymkowitz, J. & Serrano, L. Prediction of sequence-dependent and mutational effects on the aggregation of peptides and proteins. Nature biotechnology 22, 1302\u20131306 (2004). Linding, R., Schymkowitz, J., Rousseau, F., Diella, F. & Serrano, L. A comparative study of the relationship between protein structure and \u03b2-aggregation in globular and intrinsically disordered proteins. Journal of molecular biology 342, 345\u2013353 (2004). Rousseau, F., Schymkowitz, J. & Serrano, L. Protein aggregation and amyloidosis: confusion of the kinds? Current opinion in structural biology 16, 118\u2013126 (2006).","title":"Objective"},{"location":"Objective_orfold.html#aims-and-general-description-of-orfold","text":"ORFold aims at estimating the fold potential of a set of amino acid sequences using the Hydrophobic Clusters Analysis (HCA) method [1]. We define the foldability of an amino acid sequence as its ability to fold to a stable 3D structure or to a molten globule state in which the specific tertiary structure is lost whereas the secondary structures are intact. ORFold calculates the HCA foldability score of each given sequence. Furthermore, ORFold can estimate the disorder and/or aggregation propensities of the input sequences using the IUPred[2][3][4] and Tango[5][6][7] methods respectively.","title":"Aims and general description of ORFold"},{"location":"Objective_orfold.html#references","text":"Bitard-Feildel, T. & Callebaut, I. HCAtk and pyHCA: A Toolkit and Python API for the Hydrophobic Cluster Analysis of Protein Sequences. bioRxiv 249995 (2018). Dosztanyi, Z., Csizmok, V., Tompa, P. & Simon, I. The pairwise energy content estimated from amino acid composition discriminates between folded and intrinsically unstructured proteins. Journal of molecular biology 347, 827\u2013839 (2005). Doszta\u0301nyi, Z. Prediction of protein disorder based on IUPred. Protein Science 27, 331\u2013 340 (2018). Me\u0301sza\u0301ros, B., Erdo\u030bs, G. & Doszta\u0301nyi, Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46, W329\u2013W337 (2018). Fernandez-Escamilla, A.-M., Rousseau, F., Schymkowitz, J. & Serrano, L. Prediction of sequence-dependent and mutational effects on the aggregation of peptides and proteins. Nature biotechnology 22, 1302\u20131306 (2004). Linding, R., Schymkowitz, J., Rousseau, F., Diella, F. & Serrano, L. A comparative study of the relationship between protein structure and \u03b2-aggregation in globular and intrinsically disordered proteins. Journal of molecular biology 342, 345\u2013353 (2004). Rousseau, F., Schymkowitz, J. & Serrano, L. Protein aggregation and amyloidosis: confusion of the kinds? Current opinion in structural biology 16, 118\u2013126 (2006).","title":"References"},{"location":"Plot_orfold.html","text":"Plot of the ORFold output # The output table generated by ORFold can be subsequently given to ORFplot to generate a plot of the HCA score distribution. The user can provide several tables in order to compare different HCA score distributions. In this case, ORFplot will plot all the distributions on the same plot (the tables must be given with the -tab option). The HCA score distribution of a set of globular proteins extracted from [1] is represented by the grey histogram. We defined three sequence categories according to their HCA scores: low, intermediate and high HCA score sequences. The boundaries of these categories are defined so that 95% of the globular proteins fall into the intermediate HCA score bin. Dotted black lines delineate the boundaries of each category. Each plotted distribution is compared with the one of the globular proteins set with a Kolmogorov Smirnov test. Asterisks on the plot denote level of significance: * < 0.05, ** < 0.01, *** < 0.001. By default, the names used in the legend of the resulting plot are the root names of the input table files. However, the user can write his/her own names in the legend with the -names option. The names must be given in the same order as the table files. Please note that the inputs (i.e. the tables outputed by ORFold) must be stored in the /workdir/orfold/ directory of the container. orfplot -tab /workdir/orfold/sequences_Y.tab /workdir/orfold/sequences_X.tab /workdir/orfold/sequences_Z.tab This example will generate the HCA score distributions of the sequences stored in the sequences_Y.tab, sequences_X.tab and sequences_Z.tab files. The resulting legend will be sequences_Y, sequences_X, and sequences_Z respectively. orfplot -tab /workdir/orfold/sequences_Y.tab /workdir/orfold/sequences_X.tab /workdir/orfold/sequences_Z.tab -names Noncoding Coding Translated This example will generate the HCA score distributions of the sequences stored in the sequences_Y.tab, sequences_X.tab and sequences_Z.tab files. The resulting legend will be \"Noncoding\", \"Coding\" and \"Translated\", respectively. All the plots will be stored in the /workdir/orfold/ folder of the container. Note If the names consist of single words the user can write them the one after the other as shown in the example above. However, if the user wishes to use multiple words in the legend labels (ie Noncoding sequences - Homo sapiens , Coding sequences - Homo sapiens, Translated sequences - Homo sapiens) they must be enclosed in double quotes. orfplot -tab /workdir/orfold/sequences_Y.tab /workdir/orfold/sequences_X.tab /workdir/orfold/sequences_Z.tab -names \"Noncoding sequences - Homo sapiens\" \"Coding sequences - Homo sapiens\" \"Translated sequences - Homo sapiens\" References M\u00e9sz\u00e1ros B, Erd\u0151s G, Doszt\u00e1nyi Z (2018) IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46:W329\u2013W337","title":"Plots with ORFplot"},{"location":"Plot_orfold.html#plot-of-the-orfold-output","text":"The output table generated by ORFold can be subsequently given to ORFplot to generate a plot of the HCA score distribution. The user can provide several tables in order to compare different HCA score distributions. In this case, ORFplot will plot all the distributions on the same plot (the tables must be given with the -tab option). The HCA score distribution of a set of globular proteins extracted from [1] is represented by the grey histogram. We defined three sequence categories according to their HCA scores: low, intermediate and high HCA score sequences. The boundaries of these categories are defined so that 95% of the globular proteins fall into the intermediate HCA score bin. Dotted black lines delineate the boundaries of each category. Each plotted distribution is compared with the one of the globular proteins set with a Kolmogorov Smirnov test. Asterisks on the plot denote level of significance: * < 0.05, ** < 0.01, *** < 0.001. By default, the names used in the legend of the resulting plot are the root names of the input table files. However, the user can write his/her own names in the legend with the -names option. The names must be given in the same order as the table files. Please note that the inputs (i.e. the tables outputed by ORFold) must be stored in the /workdir/orfold/ directory of the container. orfplot -tab /workdir/orfold/sequences_Y.tab /workdir/orfold/sequences_X.tab /workdir/orfold/sequences_Z.tab This example will generate the HCA score distributions of the sequences stored in the sequences_Y.tab, sequences_X.tab and sequences_Z.tab files. The resulting legend will be sequences_Y, sequences_X, and sequences_Z respectively. orfplot -tab /workdir/orfold/sequences_Y.tab /workdir/orfold/sequences_X.tab /workdir/orfold/sequences_Z.tab -names Noncoding Coding Translated This example will generate the HCA score distributions of the sequences stored in the sequences_Y.tab, sequences_X.tab and sequences_Z.tab files. The resulting legend will be \"Noncoding\", \"Coding\" and \"Translated\", respectively. All the plots will be stored in the /workdir/orfold/ folder of the container. Note If the names consist of single words the user can write them the one after the other as shown in the example above. However, if the user wishes to use multiple words in the legend labels (ie Noncoding sequences - Homo sapiens , Coding sequences - Homo sapiens, Translated sequences - Homo sapiens) they must be enclosed in double quotes. orfplot -tab /workdir/orfold/sequences_Y.tab /workdir/orfold/sequences_X.tab /workdir/orfold/sequences_Z.tab -names \"Noncoding sequences - Homo sapiens\" \"Coding sequences - Homo sapiens\" \"Translated sequences - Homo sapiens\" References M\u00e9sz\u00e1ros B, Erd\u0151s G, Doszt\u00e1nyi Z (2018) IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46:W329\u2013W337","title":"Plot of the ORFold output"},{"location":"Run_orfold.html","text":"Running ORFold: # Inputs # Basically, ORFold requires only a fasta file containing the amino acid sequences to treat (given with the -fna label). ORFold can handle several fasta files at the same time. In this case, it will treat them independently and will generate as many outputs as entered fasta files. The inputs must be stored in a local directory that will be linked to the /database/ directory of the container (see here for more details). The following commands assume the user run ORFold in the container and all necessary inputs are stored in the /database/ folder of the container. fasta file example: >aminoacid_sequence_1 AGNVCFGGRTYMPDFDGMSCVNWQERT >aminoacid_sequence_2 MPDFMPCNVSDRTEEEPMSPARTYDFGHKLCVSDFTPMLKKPERT How to estimate the fold potential and/or disorder and aggregation propensities # By default, ORFold only estimates the fold potential of the input sequences. The disorder and aggregation propensities can be however calculated as well. The user can specify which calculation methods are to be launched with the -options argument. Each method used by ORFold is referred by its initial: HCA : H IUPred : I TANGO : T The user must specify the combination of methods he wants to apply on the input sequences giving their initials with the -options argument without any space: -options HIT for running the 3 programs or -options HT if the user wants to run only HCA and Tango for example. The order of the letters has no importance, -options HIT and -options THI will lead to the same result. Basic run # The following instruction estimates the fold potential, and the disorder and aggregation propensities of all amino acid sequences contained in the input fASTA file: orfold -faa /database/sequences.fasta -options HIT The user has to notice that IUPred and Tango provide additional information to HCA but will slow down considerably ORFold for large datasets. The next instruction only calculate the fold potential with HCA: orfold -fna /database/sequences.fasta -options H Output: # ORFold produces a table (fasta_rootname.tab) that contains for each input sequence, the computed values (separated by tabulations) according to the user request (fold potential, and/or disorder and/or aggregation propensities). The output(s) is/are stored in the /workdir/orfold/ directory of the container. Output file example with -options HIT (fold potential, disorder and aggregation propensities estimated from HCA, IUPred and Tango, see here for more details): Seq_ID HCA Disord Aggreg aminoacid_sequence_1 1.340 0.000 0.230 aminoacid_sequence_2 -0.230 0.120 0.012 Output file example with -options H (fold potential estimated with HCA, see here for more details): Seq_ID HCA Disord Aggreg aminoacid_sequence_1 1.340 nan nan aminoacid_sequence_2 -0.230 nan nan","title":"Basic run ORFold"},{"location":"Run_orfold.html#running-orfold","text":"","title":"Running ORFold:"},{"location":"Run_orfold.html#inputs","text":"Basically, ORFold requires only a fasta file containing the amino acid sequences to treat (given with the -fna label). ORFold can handle several fasta files at the same time. In this case, it will treat them independently and will generate as many outputs as entered fasta files. The inputs must be stored in a local directory that will be linked to the /database/ directory of the container (see here for more details). The following commands assume the user run ORFold in the container and all necessary inputs are stored in the /database/ folder of the container. fasta file example: >aminoacid_sequence_1 AGNVCFGGRTYMPDFDGMSCVNWQERT >aminoacid_sequence_2 MPDFMPCNVSDRTEEEPMSPARTYDFGHKLCVSDFTPMLKKPERT","title":"Inputs"},{"location":"Run_orfold.html#how-to-estimate-the-fold-potential-andor-disorder-and-aggregation-propensities","text":"By default, ORFold only estimates the fold potential of the input sequences. The disorder and aggregation propensities can be however calculated as well. The user can specify which calculation methods are to be launched with the -options argument. Each method used by ORFold is referred by its initial: HCA : H IUPred : I TANGO : T The user must specify the combination of methods he wants to apply on the input sequences giving their initials with the -options argument without any space: -options HIT for running the 3 programs or -options HT if the user wants to run only HCA and Tango for example. The order of the letters has no importance, -options HIT and -options THI will lead to the same result.","title":"How to estimate the fold potential and/or disorder and aggregation propensities"},{"location":"Run_orfold.html#basic-run","text":"The following instruction estimates the fold potential, and the disorder and aggregation propensities of all amino acid sequences contained in the input fASTA file: orfold -faa /database/sequences.fasta -options HIT The user has to notice that IUPred and Tango provide additional information to HCA but will slow down considerably ORFold for large datasets. The next instruction only calculate the fold potential with HCA: orfold -fna /database/sequences.fasta -options H","title":"Basic run"},{"location":"Run_orfold.html#output","text":"ORFold produces a table (fasta_rootname.tab) that contains for each input sequence, the computed values (separated by tabulations) according to the user request (fold potential, and/or disorder and/or aggregation propensities). The output(s) is/are stored in the /workdir/orfold/ directory of the container. Output file example with -options HIT (fold potential, disorder and aggregation propensities estimated from HCA, IUPred and Tango, see here for more details): Seq_ID HCA Disord Aggreg aminoacid_sequence_1 1.340 0.000 0.230 aminoacid_sequence_2 -0.230 0.120 0.012 Output file example with -options H (fold potential estimated with HCA, see here for more details): Seq_ID HCA Disord Aggreg aminoacid_sequence_1 1.340 nan nan aminoacid_sequence_2 -0.230 nan nan","title":"Output:"},{"location":"Run_orfold_advanced.html","text":"Running ORFold: # Advanced run: # Mapping of the fold potential and the disorder and aggregation propensities along the genome of an organism # In the previous section we presented how to launch ORFold on a set of amino acid sequences stored in a fasta file. However, the originality of ORFold relies on the fact that the user can manually inspect the distribution of the properties estimated with ORFold (fold potential, and disorder and aggregation propensities) along a genome of interest. In this case, the user must provide the genome annotation file (gff) along with the input fasta file. ORFold will return new gff files (one per studied property) that contain for the ORFs provided in the input fasta file, their corresponding property scores (fold potential, disorder or aggregation propensities). The values are stored in the column #9 of the output gff files. The gff files can be subsequently uploaded on a genome viewer such as IGV [1]. The input gff file must be given with the -gff option as follows: orfold -faa /database/sequences.fasta -options HIT -gff /database/sequences.gff ORFold generates a sequences.tab file containing the fold potential, and the disorder and aggregation propensities of each sequence present in the input fasta file. Additionally, ORFold produces three new gff files: sequences_HCA.gff sequences_IUPRED.gff sequences_TANGO.gff The output gff files are identical to the one provided by the user except that for the sequences present at the same time in the fasta and the gff files that were given as inputs, the column #9 is now replaced by the fold potential, or the disorder or aggregation propensities calculated by ORFold. That way, the corresponding sequences can be colored according to these values on a genome viewer, thereby enabling the visual inspection of these properties along the input genome. Notice that on IGV, blue indicates low values (for all mapped properties) while red indicates high values. Figure 1: Color scale for the HCA score values Note Notice that the ID of the sequences given in the fasta file (i.e. annotation after the \">\" in the fasta file) must be strictly identical to those of the corresponding sequences in the gff file (i.e. ID indicated in the column #3 of the gff file). Dealing with multiple files at the same time: # ORFold can handle multiple input files (fasta and gff) and will associate the fasta and gff files according to the following rules: If the user provides the same number of fasta and gff files, ORFold associates them based on their root name, no matter the order of the files. orfold -faa /database/sequences_Y.fasta /database/sequences_X.fasta -options H -gff /database/sequences_X.gff /database/sequences_Y.gff In this case, ORFold associates: sequence_Y.fasta with sequence_Y.gff sequence_X.fasta with sequence_X.gff I If the user provides the same number of fasta and gff files, but their root names are not identical, ORFold associates them according to the order of the files in the command line. orfold -faa /database/sequences_Y.fasta /database/sequences_X.fasta -options H -gff /database/sequences_A.gff /database/sequences_B.gff In this case, ORFold associates: sequence_Y.fasta with sequence_A.gff sequence_X.fasta with sequence_B.gff If the user provides multiple fasta files and only one gff file, then: If the name of the gff file matches with the name of one of the fasta files, the two files are associated, while the other fasta files are not associated to the input gff file. orfold -faa /database/sequences_Y.fasta /database/sequences_X.fasta -options H -gff /database/sequences_X.gff ORFold associates: sequences_X.fasta with sequences_X.gff sequences_Y.fasta with nothing If the name of the gff file does not match with any of the names of the fasta files, then the gff file will be associated with all the fasta files, considering that the fasta files correspond to different subgroups of the same dataset. orfold -faa /database/sequences_Y.fasta /database/sequences_X.fasta -options H -gff /database/sequences_B.gff ORFold associates: sequences_Y.fasta with sequences_B.gff sequences_X.fasta with sequences_B.gff If the user provides multiple fasta and gff files (but not the same number), all gff files must have a corresponding fasta file with the same root name. Otherwise, ORFold will give an ERROR message. orfold -faa /database/sequences_Y.fasta /database/sequences_X.fasta /database/sequences_Z.fasta -options H -gff /database/sequences_Z.fasta /database/sequences_Y.gff ORFold associates: sequences_Y.fasta with sequences_Y.gff sequences_Z.fasta with sequences_Z.gff sequences_X.fasta with nothing orfold -faa /database/sequences_Y.fasta /database/sequences_X.fasta /database/sequences_Z.fasta -options H -gff /database/sequences_B.fasta /database/sequences_A.gff ORFold will give the following error message: Oups! You provided GFF file(s) which has/have no correspondance to the input FASTA files All these examples assume that the input files are stored in the /database/ directory of the container. All the outputs are written in the /workdir/orfold/ directory of the container. Running ORFold on subsets of randomly selected sequences # Working with complete genomes could generate big amounts of sequences which can dramatically increase the computational time of ORFold when dealing with large genomes (especially if the estimation of the disorder and aggregation propensities are activated). If the user does not want to treat all the sequences, he/she can create a random sample of the input sequences, large enough to have an estimation of the distribution of the studied properties of its dataset from a representative sample of the input sequences. To do so, the user must indicate the number of sequences that are to be randomly selected with the -N option. For a representative dataset, we recommend selecting at least 10000 sequences. orfold -faa /database/sequences.fasta -options HIT -gff /database/sequences.gff -N 10000 In this example, ORFold will estimate the fold potential, and the disorder and aggregation propensities on a sample of 10000 sequences extracted randomly from the initial sequences.fasta file. Note If the user works with more than one fasta file and wishes to create random samples for all the input sequence files, he/she has to indicate in the -N option the size for each input file explicitly (in the same order as the inputs passed in the -fna option). orfold -faa /database/sequences_X.pfasta /database/sequences_Y.pfasta -options H -N 1500 3000 Also, if the user wants to sample two subsets of same sizes, he/she has to indicate the subset sizes explicitly for each input orfold -faa /database/sequences_X.pfasta /database/sequences_Y.pfasta -options H -N 1500 1500 If the user whishes to calculate the fold potential of all the sequences of one of the given inputs, he has to indicate it with the \"all\" flag (again with respect to the order of input files) orfold -faa /database/sequences_X.pfasta /database/sequences_Y.pfasta -options H -N all 3000 In this case, ORFold will calculate the fold potential for all the sequences in the sequences_X file while will generate a random sample of 3000 sequences for the sequences_Y file. References Robinson JT, Thorvaldsd\u00f3ttir H, Winckler W, et al (2011) Integrative genomics viewer. Nature biotechnology 29:24\u201326","title":"Advanced run ORFold"},{"location":"Run_orfold_advanced.html#running-orfold","text":"","title":"Running ORFold:"},{"location":"Run_orfold_advanced.html#advanced-run","text":"","title":"Advanced run:"},{"location":"Run_orfold_advanced.html#mapping-of-the-fold-potential-and-the-disorder-and-aggregation-propensities-along-the-genome-of-an-organism","text":"In the previous section we presented how to launch ORFold on a set of amino acid sequences stored in a fasta file. However, the originality of ORFold relies on the fact that the user can manually inspect the distribution of the properties estimated with ORFold (fold potential, and disorder and aggregation propensities) along a genome of interest. In this case, the user must provide the genome annotation file (gff) along with the input fasta file. ORFold will return new gff files (one per studied property) that contain for the ORFs provided in the input fasta file, their corresponding property scores (fold potential, disorder or aggregation propensities). The values are stored in the column #9 of the output gff files. The gff files can be subsequently uploaded on a genome viewer such as IGV [1]. The input gff file must be given with the -gff option as follows: orfold -faa /database/sequences.fasta -options HIT -gff /database/sequences.gff ORFold generates a sequences.tab file containing the fold potential, and the disorder and aggregation propensities of each sequence present in the input fasta file. Additionally, ORFold produces three new gff files: sequences_HCA.gff sequences_IUPRED.gff sequences_TANGO.gff The output gff files are identical to the one provided by the user except that for the sequences present at the same time in the fasta and the gff files that were given as inputs, the column #9 is now replaced by the fold potential, or the disorder or aggregation propensities calculated by ORFold. That way, the corresponding sequences can be colored according to these values on a genome viewer, thereby enabling the visual inspection of these properties along the input genome. Notice that on IGV, blue indicates low values (for all mapped properties) while red indicates high values. Figure 1: Color scale for the HCA score values Note Notice that the ID of the sequences given in the fasta file (i.e. annotation after the \">\" in the fasta file) must be strictly identical to those of the corresponding sequences in the gff file (i.e. ID indicated in the column #3 of the gff file).","title":"Mapping of the fold potential and the disorder and aggregation propensities along the genome of an organism"},{"location":"Run_orfold_advanced.html#dealing-with-multiple-files-at-the-same-time","text":"ORFold can handle multiple input files (fasta and gff) and will associate the fasta and gff files according to the following rules: If the user provides the same number of fasta and gff files, ORFold associates them based on their root name, no matter the order of the files. orfold -faa /database/sequences_Y.fasta /database/sequences_X.fasta -options H -gff /database/sequences_X.gff /database/sequences_Y.gff In this case, ORFold associates: sequence_Y.fasta with sequence_Y.gff sequence_X.fasta with sequence_X.gff I If the user provides the same number of fasta and gff files, but their root names are not identical, ORFold associates them according to the order of the files in the command line. orfold -faa /database/sequences_Y.fasta /database/sequences_X.fasta -options H -gff /database/sequences_A.gff /database/sequences_B.gff In this case, ORFold associates: sequence_Y.fasta with sequence_A.gff sequence_X.fasta with sequence_B.gff If the user provides multiple fasta files and only one gff file, then: If the name of the gff file matches with the name of one of the fasta files, the two files are associated, while the other fasta files are not associated to the input gff file. orfold -faa /database/sequences_Y.fasta /database/sequences_X.fasta -options H -gff /database/sequences_X.gff ORFold associates: sequences_X.fasta with sequences_X.gff sequences_Y.fasta with nothing If the name of the gff file does not match with any of the names of the fasta files, then the gff file will be associated with all the fasta files, considering that the fasta files correspond to different subgroups of the same dataset. orfold -faa /database/sequences_Y.fasta /database/sequences_X.fasta -options H -gff /database/sequences_B.gff ORFold associates: sequences_Y.fasta with sequences_B.gff sequences_X.fasta with sequences_B.gff If the user provides multiple fasta and gff files (but not the same number), all gff files must have a corresponding fasta file with the same root name. Otherwise, ORFold will give an ERROR message. orfold -faa /database/sequences_Y.fasta /database/sequences_X.fasta /database/sequences_Z.fasta -options H -gff /database/sequences_Z.fasta /database/sequences_Y.gff ORFold associates: sequences_Y.fasta with sequences_Y.gff sequences_Z.fasta with sequences_Z.gff sequences_X.fasta with nothing orfold -faa /database/sequences_Y.fasta /database/sequences_X.fasta /database/sequences_Z.fasta -options H -gff /database/sequences_B.fasta /database/sequences_A.gff ORFold will give the following error message: Oups! You provided GFF file(s) which has/have no correspondance to the input FASTA files All these examples assume that the input files are stored in the /database/ directory of the container. All the outputs are written in the /workdir/orfold/ directory of the container.","title":"Dealing with multiple files at the same time:"},{"location":"Run_orfold_advanced.html#running-orfold-on-subsets-of-randomly-selected-sequences","text":"Working with complete genomes could generate big amounts of sequences which can dramatically increase the computational time of ORFold when dealing with large genomes (especially if the estimation of the disorder and aggregation propensities are activated). If the user does not want to treat all the sequences, he/she can create a random sample of the input sequences, large enough to have an estimation of the distribution of the studied properties of its dataset from a representative sample of the input sequences. To do so, the user must indicate the number of sequences that are to be randomly selected with the -N option. For a representative dataset, we recommend selecting at least 10000 sequences. orfold -faa /database/sequences.fasta -options HIT -gff /database/sequences.gff -N 10000 In this example, ORFold will estimate the fold potential, and the disorder and aggregation propensities on a sample of 10000 sequences extracted randomly from the initial sequences.fasta file. Note If the user works with more than one fasta file and wishes to create random samples for all the input sequence files, he/she has to indicate in the -N option the size for each input file explicitly (in the same order as the inputs passed in the -fna option). orfold -faa /database/sequences_X.pfasta /database/sequences_Y.pfasta -options H -N 1500 3000 Also, if the user wants to sample two subsets of same sizes, he/she has to indicate the subset sizes explicitly for each input orfold -faa /database/sequences_X.pfasta /database/sequences_Y.pfasta -options H -N 1500 1500 If the user whishes to calculate the fold potential of all the sequences of one of the given inputs, he has to indicate it with the \"all\" flag (again with respect to the order of input files) orfold -faa /database/sequences_X.pfasta /database/sequences_Y.pfasta -options H -N all 3000 In this case, ORFold will calculate the fold potential for all the sequences in the sequences_X file while will generate a random sample of 3000 sequences for the sequences_Y file. References Robinson JT, Thorvaldsd\u00f3ttir H, Winckler W, et al (2011) Integrative genomics viewer. Nature biotechnology 29:24\u201326","title":"Running ORFold on subsets of randomly selected sequences"},{"location":"dependencies.html","text":"Programs and Dependencies # _libgcc_mutex=0.1=conda_forge _openmp_mutex=4.5=2_gnu _r-mutex=1.0.1=anacondar_1 aioeasywebdav=2.4.0=pyha770c72_0 aiohttp=3.8.3=py310h5764c6d_0 aiosignal=1.2.0=pyhd8ed1ab_0 alsa-lib=1.2.3.2=h166bdaf_0 amply=0.1.5=pyhd8ed1ab_0 aom=3.3.0=h27087fc_1 appdirs=1.4.4=pyh9f0ad1d_0 argcomplete=2.0.0=pyhd8ed1ab_0 argh=0.26.2=pyh9f0ad1d_1002 async-timeout=4.0.2=pyhd8ed1ab_0 atk-1.0=2.36.0=h3371d22_4 attmap=0.13.2=pyhd8ed1ab_0 attrs=22.1.0=pyh71513ae_1 backports=1.0=py_2 backports.functools_lru_cache=1.6.4=pyhd8ed1ab_0 bcrypt=3.2.2=py310h5764c6d_0 binutils_impl_linux-64=2.39=h6ceecb4_0 binutils_linux-64=2.39=h5fc0e48_11 bioconductor-annotationdbi=1.56.2=r41hdfd78af_0 bioconductor-biobase=2.54.0=r41hc0cfd56_2 bioconductor-biocfilecache=2.2.0=r41hdfd78af_0 bioconductor-biocgenerics=0.40.0=r41hdfd78af_0 bioconductor-biocio=1.4.0=r41hdfd78af_0 bioconductor-biocparallel=1.28.3=r41hc247a5b_1 bioconductor-biomart=2.50.0=r41hdfd78af_0 bioconductor-biostrings=2.62.0=r41hc0cfd56_2 bioconductor-delayedarray=0.20.0=r41hc0cfd56_2 bioconductor-genomeinfodb=1.30.1=r41hdfd78af_0 bioconductor-genomeinfodbdata=1.2.6=r41hdfd78af_0 bioconductor-genomicalignments=1.30.0=r41hc0cfd56_2 bioconductor-genomicfeatures=1.46.1=r41hdfd78af_0 bioconductor-genomicranges=1.46.1=r41hc0cfd56_1 bioconductor-iranges=2.28.0=r41hc0cfd56_2 bioconductor-keggrest=1.34.0=r41hdfd78af_0 bioconductor-matrixgenerics=1.6.0=r41hdfd78af_0 bioconductor-rhtslib=1.26.0=r41hc0cfd56_2 bioconductor-rsamtools=2.10.0=r41hc247a5b_2 bioconductor-rtracklayer=1.54.0=r41h171f361_4 bioconductor-s4vectors=0.32.4=r41hc0cfd56_0 bioconductor-summarizedexperiment=1.24.0=r41hdfd78af_0 bioconductor-xvector=0.34.0=r41hc0cfd56_2 bioconductor-zlibbioc=1.40.0=r41hc0cfd56_2 biopython=1.79=py310h5764c6d_2 blast=2.13.0=hf3cf87c_0 boto3=1.25.1=pyhd8ed1ab_0 botocore=1.28.1=pyhd8ed1ab_0 bowtie2=2.4.5=py310h8d7afc0_4 brotli=1.0.9=h166bdaf_8 brotli-bin=1.0.9=h166bdaf_8 brotlipy=0.7.0=py310h5764c6d_1005 bwidget=1.9.14=ha770c72_1 bzip2=1.0.8=h7f98852_4 c-ares=1.18.1=h7f98852_0 ca-certificates=2022.9.24=ha878542_0 cachetools=5.2.0=pyhd8ed1ab_0 cairo=1.16.0=ha12eb4b_1010 cairocffi=1.3.0=pyhd8ed1ab_0 cairosvg=2.5.2=pyhd8ed1ab_0 certifi=2022.9.24=pyhd8ed1ab_0 cffi=1.15.1=py310h255011f_2 charset-normalizer=2.1.1=pyhd8ed1ab_0 coin-or-cbc=2.10.8=h3786ebc_0 coin-or-cgl=0.60.6=h6f57e76_1 coin-or-clp=1.17.7=h256e9bb_0 coin-or-osi=0.108.7=h2720bb7_2 coin-or-utils=2.11.6=h202d8b1_2 coincbc=2.10.8=0_metapackage commonmark=0.9.1=py_0 configargparse=1.5.3=pyhd8ed1ab_0 connection_pool=0.0.3=pyhd3deb0d_0 contourpy=1.0.5=py310hbf28c38_0 cryptography=38.0.2=py310h597c629_1 cssselect2=0.2.1=pyh9f0ad1d_1 curl=7.86.0=h7bff187_0 cutadapt=4.1=py310h1425a21_1 cycler=0.11.0=pyhd8ed1ab_0 dataclasses=0.8=pyhc8e2a94_3 datrie=0.8.2=py310h6acc77f_3 dbus=1.13.6=h5008d03_3 defusedxml=0.7.1=pyhd8ed1ab_0 dendropy=4.5.2=pyh3252c3a_0 dnaio=0.9.1=py310h1425a21_1 docutils=0.19=py310hff52083_1 dpath=2.0.6=py310hff52083_1 dropbox=11.35.0=pyhd8ed1ab_0 entrez-direct=16.2=he881be0_1 ete3=3.1.2=pyh9f0ad1d_0 exceptiongroup=1.0.0rc9=pyhd8ed1ab_0 expat=2.5.0=h27087fc_0 fastqc=0.11.9=hdfd78af_1 ffmpeg=4.4.1=hd7ab26d_2 filechunkio=1.8=py_2 filelock=3.8.0=pyhd8ed1ab_0 font-ttf-dejavu-sans-mono=2.37=hab24e00_0 font-ttf-inconsolata=3.000=h77eed37_0 font-ttf-source-code-pro=2.038=h77eed37_0 font-ttf-ubuntu=0.83=hab24e00_0 fontconfig=2.14.1=hc2a2eb6_0 fonts-conda-ecosystem=1=0 fonts-conda-forge=1=0 fonttools=4.38.0=py310h5764c6d_0 freeglut=3.2.2=h9c3ff4c_1 freetype=2.12.1=hca18f0e_0 fribidi=1.0.10=h36c2ea0_0 frozenlist=1.3.1=py310h5764c6d_1 ftputil=5.0.4=pyhd8ed1ab_0 future=0.18.2=pyhd8ed1ab_6 gawk=5.1.0=h7f98852_0 gcc_impl_linux-64=9.5.0=h99780fb_19 gcc_linux-64=9.5.0=h4258300_11 gdk-pixbuf=2.42.8=hff1cb4f_1 gettext=0.21.1=h27087fc_0 gffread=0.12.7=hd03093a_1 gffutils=0.11.1=pyh7cba7a3_0 gfortran_impl_linux-64=9.5.0=hf1096a2_19 gfortran_linux-64=9.5.0=hdb51d14_11 giflib=5.2.1=h36c2ea0_2 gitdb=4.0.9=pyhd8ed1ab_0 gitpython=3.1.29=pyhd8ed1ab_0 gmp=6.2.1=h58526e2_0 gnutls=3.6.13=h85f3911_1 google-api-core=2.10.1=pyhd8ed1ab_0 google-api-python-client=2.65.0=pyhd8ed1ab_0 google-auth=2.13.0=pyh1a96a4e_0 google-auth-httplib2=0.1.0=pyhd8ed1ab_1 google-cloud-core=2.3.2=pyhd8ed1ab_0 google-cloud-storage=2.5.0=pyh6c4a22f_0 google-crc32c=1.1.2=py310he8fe98e_3 google-resumable-media=2.4.0=pyhd8ed1ab_0 googleapis-common-protos=1.56.4=py310hff52083_0 graphite2=1.3.13=h58526e2_1001 graphviz=3.0.0=h5abf519_1 grpc-cpp=1.48.1=hbad87ad_1 grpcio=1.48.1=py310h946def9_1 gsl=2.7=he838d99_0 gst-plugins-base=1.18.5=hf529b03_3 gstreamer=1.18.5=h9f60fe5_3 gtk2=2.24.33=h90689f9_2 gts=0.7.6=h64030ff_2 gxx_impl_linux-64=9.5.0=h99780fb_19 gxx_linux-64=9.5.0=h43f449f_11 harfbuzz=4.2.0=h40b6f09_0 hdf5=1.12.1=nompi_h2386368_104 hisat2=2.2.1=h87f3376_4 htslib=1.14=h9753748_2 httplib2=0.20.4=pyhd8ed1ab_0 icu=69.1=h9c3ff4c_0 idna=3.4=pyhd8ed1ab_0 importlib-metadata=4.11.4=py310hff52083_0 importlib_metadata=4.11.4=hd8ed1ab_0 importlib_resources=5.10.0=pyhd8ed1ab_0 iniconfig=1.1.1=pyh9f0ad1d_0 isa-l=2.30.0=ha770c72_4 jasper=2.0.33=ha77e612_0 jinja2=3.1.2=pyhd8ed1ab_1 jmespath=1.0.1=pyhd8ed1ab_0 joblib=1.2.0=pyhd8ed1ab_0 jpeg=9e=h166bdaf_2 jsonschema=4.16.0=pyhd8ed1ab_0 jupyter_core=4.11.1=py310hff52083_0 kernel-headers_linux-64=2.6.32=he073ed8_15 keyutils=1.6.1=h166bdaf_0 kiwisolver=1.4.4=py310hbf28c38_0 krb5=1.19.3=h3790be6_0 lame=3.100=h166bdaf_1003 lcms2=2.12=hddcbb42_0 ld_impl_linux-64=2.39=hc81fddc_0 lerc=3.0=h9c3ff4c_0 libabseil=20220623.0=cxx17_h48a1fff_4 libblas=3.9.0=16_linux64_openblas libbrotlicommon=1.0.9=h166bdaf_8 libbrotlidec=1.0.9=h166bdaf_8 libbrotlienc=1.0.9=h166bdaf_8 libcblas=3.9.0=16_linux64_openblas libclang=13.0.1=default_hc23dcda_0 libcrc32c=1.1.2=h9c3ff4c_0 libcurl=7.86.0=h7bff187_0 libdeflate=1.10=h7f98852_0 libdrm=2.4.113=h166bdaf_0 libedit=3.1.20191231=he28a2e2_2 libev=4.33=h516909a_1 libevent=2.1.10=h9b69904_4 libffi=3.4.2=h7f98852_5 libgcc-devel_linux-64=9.5.0=h0a57e50_19 libgcc-ng=12.2.0=h65d4601_19 libgd=2.3.3=h283352f_2 libgfortran-ng=12.2.0=h69a702a_19 libgfortran5=12.2.0=h337968e_19 libgit2=1.5.0=h6529ace_0 libglib=2.74.1=h7a41b64_0 libglu=9.0.0=he1b5a44_1001 libgomp=12.2.0=h65d4601_19 libiconv=1.17=h166bdaf_0 libidn2=2.3.4=h166bdaf_0 liblapack=3.9.0=16_linux64_openblas liblapacke=3.9.0=16_linux64_openblas libllvm13=13.0.1=hf817b99_2 libnghttp2=1.47.0=hdcd2b5c_1 libnsl=2.0.0=h7f98852_0 libogg=1.3.4=h7f98852_1 libopenblas=0.3.21=pthreads_h78a6416_3 libopencv=4.5.5=py310hc83fb77_10 libopus=1.3.1=h7f98852_1 libpciaccess=0.16=h516909a_0 libpng=1.6.38=h753d276_0 libpq=14.3=hd77ab85_0 libprotobuf=3.20.1=h6239696_4 librsvg=2.52.5=h0a9e6e8_3 libsanitizer=9.5.0=h2f262e1_19 libsodium=1.0.18=h36c2ea0_1 libssh2=1.10.0=haa6b8db_3 libstdcxx-devel_linux-64=9.5.0=h0a57e50_19 libstdcxx-ng=12.2.0=h46fd767_19 libtiff=4.4.0=h0fcbabc_0 libtool=2.4.6=h9c3ff4c_1008 libunistring=0.9.10=h7f98852_0 libuuid=2.32.1=h7f98852_1000 libva=2.16.0=h166bdaf_0 libvorbis=1.3.7=h9c3ff4c_0 libvpx=1.11.0=h9c3ff4c_3 libwebp=1.2.4=h522a892_0 libwebp-base=1.2.4=h166bdaf_0 libxcb=1.13=h7f98852_1004 libxkbcommon=1.0.3=he3ba5ed_0 libxml2=2.9.12=h885dcf4_1 libxslt=1.1.33=h0ef7038_3 libzlib=1.2.13=h166bdaf_4 lightgbm=3.3.3=py310hd8f1fbe_0 logmuse=0.2.6=pyh8c360ce_0 lxml=4.8.0=py310h5764c6d_2 make=4.3=hd18ef5c_1 markupsafe=2.1.1=py310h5764c6d_2 matplotlib=3.6.0=py310hff52083_0 matplotlib-base=3.6.0=py310h8d5ebf3_0 multidict=6.0.2=py310h5764c6d_1 munkres=1.1.4=pyh9f0ad1d_0 mysql-common=8.0.31=haf5c9bc_0 mysql-libs=8.0.31=h28c427c_0 nano=2.9.8=hddfc1eb_1001 nbformat=5.7.0=pyhd8ed1ab_0 ncurses=6.2=h58526e2_4 nettle=3.6=he412f7d_0 nspr=4.32=h9c3ff4c_1 nss=3.74=hb5efdd6_0 numpy=1.23.4=py310h53a5b5f_1 oauth2client=4.1.3=py_0 openh264=2.1.1=h780b84a_0 openjdk=11.0.1=h516909a_1016 openjpeg=2.5.0=h7d73246_1 openssl=1.1.1s=h166bdaf_0 packaging=21.3=pyhd8ed1ab_0 pandas=1.5.1=py310h769672d_0 pandoc=2.19.2=h32600fe_1 pango=1.50.7=hbd2fdc8_0 paramiko=2.11.0=pyhd8ed1ab_0 patsy=0.5.3=pyhd8ed1ab_0 pbzip2=1.1.13=0 pcre=8.45=h9c3ff4c_0 pcre2=10.37=hc3806b6_1 peppy=0.35.2=pyhd8ed1ab_0 perl=5.32.1=2_h7f98852_perl5 perl-archive-tar=2.40=pl5321hdfd78af_0 perl-carp=1.50=pl5321hd8ed1ab_0 perl-common-sense=3.75=pl5321hd8ed1ab_0 perl-compress-raw-bzip2=2.201=pl5321h166bdaf_0 perl-compress-raw-zlib=2.202=pl5321h166bdaf_0 perl-encode=3.19=pl5321h166bdaf_0 perl-exporter=5.74=pl5321hd8ed1ab_0 perl-exporter-tiny=1.002002=pl5321hd8ed1ab_0 perl-extutils-makemaker=7.64=pl5321hd8ed1ab_0 perl-io-compress=2.201=pl5321h87f3376_0 perl-io-zlib=1.11=pl5321hdfd78af_0 perl-json=4.10=pl5321hdfd78af_0 perl-json-xs=2.34=pl5321h9f5acd7_5 perl-list-moreutils=0.430=pl5321hdfd78af_0 perl-list-moreutils-xs=0.430=pl5321hec16e2b_1 perl-parent=0.238=pl5321hd8ed1ab_0 perl-pathtools=3.75=pl5321h166bdaf_0 perl-scalar-list-utils=1.63=pl5321h166bdaf_0 perl-storable=3.15=pl5321h166bdaf_0 perl-types-serialiser=1.01=pl5321hdfd78af_0 pigz=2.6=h27826a3_0 pillow=9.2.0=py310hbd86126_2 pip=22.3=pyhd8ed1ab_0 pixman=0.40.0=h36c2ea0_0 pkgutil-resolve-name=1.3.10=pyhd8ed1ab_0 plac=1.3.5=pyhd8ed1ab_0 pluggy=1.0.0=py310hff52083_4 ply=3.11=py_1 prettytable=3.4.1=pyhd8ed1ab_0 protobuf=3.20.1=py310hd8f1fbe_0 psutil=5.9.3=py310h5764c6d_1 pthread-stubs=0.4=h36c2ea0_1001 pulp=2.6.0=py310hff52083_1 py-opencv=4.5.5=py310hfdc917e_10 pyasn1=0.4.8=py_0 pyasn1-modules=0.2.7=py_0 pycparser=2.21=pyhd8ed1ab_0 pyfaidx=0.7.1=pyh5e36f6f_0 pygments=2.13.0=pyhd8ed1ab_0 pynacl=1.5.0=py310h5764c6d_1 pyopenssl=22.1.0=pyhd8ed1ab_0 pyparsing=3.0.9=pyhd8ed1ab_0 pyqt=5.12.3=py310hff52083_8 pyqt-impl=5.12.3=py310h1f8e252_8 pyqt5-sip=4.19.18=py310h122e73d_8 pyqtchart=5.12=py310hfcd6d55_8 pyqtwebengine=5.12.1=py310hfcd6d55_8 pyrsistent=0.18.1=py310h5764c6d_2 pysam=0.19.1=py310hd89ff4b_0 pysftp=0.2.9=py_1 pysocks=1.7.1=pyha2e5f31_6 pytest=7.2.0=py310hff52083_0 python=3.10.2=h62f1059_0_cpython python-dateutil=2.8.2=pyhd8ed1ab_0 python-fastjsonschema=2.16.2=pyhd8ed1ab_0 python-irodsclient=1.1.5=pyhd8ed1ab_0 python-isal=1.1.0=py310h5764c6d_0 python_abi=3.10=2_cp310 pytz=2022.5=pyhd8ed1ab_0 pyu2f=0.1.5=pyhd8ed1ab_0 pyvcf3=1.0.3=pyhdfd78af_0 pyyaml=6.0=py310h5764c6d_5 qt=5.12.9=ha98a1a1_5 r-askpass=1.1=r41h06615bd_3 r-assertthat=0.2.1=r41hc72bb7e_3 r-backports=1.4.1=r41h06615bd_1 r-base=4.1.2=h2553ce4_1 r-base64enc=0.1_3=r41h06615bd_1005 r-bh=1.78.0_0=r41hc72bb7e_1 r-bit=4.0.4=r41h06615bd_1 r-bit64=4.0.5=r41h06615bd_1 r-bitops=1.0_7=r41h06615bd_1 r-blob=1.2.3=r41hc72bb7e_1 r-brew=1.0_8=r41hc72bb7e_1 r-brio=1.1.3=r41h06615bd_1 r-bslib=0.4.0=r41hc72bb7e_1 r-cachem=1.0.6=r41h06615bd_1 r-callr=3.7.2=r41hc72bb7e_1 r-cli=3.4.1=r41h7525677_1 r-clipr=0.8.0=r41hc72bb7e_1 r-colorspace=2.0_3=r41h06615bd_1 r-commonmark=1.8.1=r41h06615bd_0 r-cpp11=0.4.3=r41hc72bb7e_0 r-crayon=1.5.2=r41hc72bb7e_1 r-credentials=1.3.2=r41hc72bb7e_1 r-curl=4.3.3=r41h06615bd_1 r-data.table=1.14.4=r41h06615bd_0 r-dbi=1.1.3=r41hc72bb7e_1 r-dbplyr=2.2.1=r41hc72bb7e_1 r-desc=1.4.2=r41hc72bb7e_1 r-devtools=2.4.5=r41hc72bb7e_1 r-diffobj=0.3.5=r41h06615bd_1 r-digest=0.6.30=r41h7525677_0 r-downlit=0.4.2=r41hc72bb7e_1 r-dplyr=1.0.10=r41h7525677_1 r-ellipsis=0.3.2=r41h06615bd_1 r-evaluate=0.17=r41hc72bb7e_1 r-fansi=1.0.3=r41h06615bd_1 r-farver=2.1.1=r41h7525677_1 r-fastmap=1.1.0=r41h7525677_1 r-filelock=1.0.2=r41h06615bd_1003 r-fontawesome=0.4.0=r41hc72bb7e_0 r-formatr=1.12=r41hc72bb7e_1 r-fs=1.5.2=r41h7525677_2 r-futile.logger=1.4.3=r41hc72bb7e_1004 r-futile.options=1.0.1=r41hc72bb7e_1003 r-generics=0.1.3=r41hc72bb7e_1 r-gert=1.5.0=r41h163148b_3 r-ggplot2=3.3.6=r41hc72bb7e_1 r-ggrepel=0.9.1=r41h7525677_1 r-gh=1.3.1=r41hc72bb7e_1 r-gitcreds=0.1.2=r41hc72bb7e_1 r-glue=1.6.2=r41h06615bd_1 r-gtable=0.3.1=r41hc72bb7e_1 r-highr=0.9=r41hc72bb7e_1 r-hms=1.1.2=r41hc72bb7e_1 r-htmltools=0.5.3=r41h7525677_1 r-htmlwidgets=1.5.4=r41hc72bb7e_1 r-httpuv=1.6.6=r41h7525677_1 r-httr=1.4.4=r41hc72bb7e_1 r-ini=0.3.1=r41hc72bb7e_1004 r-isoband=0.2.6=r41h7525677_1 r-jquerylib=0.1.4=r41hc72bb7e_1 r-jsonlite=1.8.3=r41h06615bd_0 r-knitr=1.40=r41hc72bb7e_1 r-labeling=0.4.2=r41hc72bb7e_2 r-lambda.r=1.2.4=r41hc72bb7e_2 r-later=1.2.0=r41h7525677_1 r-lattice=0.20_45=r41h06615bd_1 r-lifecycle=1.0.3=r41hc72bb7e_1 r-magrittr=2.0.3=r41h06615bd_1 r-mass=7.3_58.1=r41h06615bd_1 r-matrix=1.5_1=r41h5f7b363_0 r-matrixstats=0.62.0=r41h06615bd_1 r-memoise=2.0.1=r41hc72bb7e_1 r-mgcv=1.8_41=r41h5f7b363_0 r-mime=0.12=r41h06615bd_1 r-miniui=0.1.1.1=r41hc72bb7e_1003 r-munsell=0.5.0=r41hc72bb7e_1005 r-nlme=3.1_160=r41h8da6f51_0 r-openssl=2.0.4=r41hfaab4ff_0 r-pillar=1.8.1=r41hc72bb7e_1 r-pkgbuild=1.3.1=r41hc72bb7e_1 r-pkgconfig=2.0.3=r41hc72bb7e_2 r-pkgdown=2.0.6=r41hc72bb7e_1 r-pkgload=1.3.0=r41hc72bb7e_1 r-plogr=0.2.0=r41hc72bb7e_1004 r-png=0.1_7=r41h06615bd_1005 r-praise=1.0.0=r41hc72bb7e_1006 r-prettyunits=1.1.1=r41hc72bb7e_2 r-processx=3.7.0=r41h06615bd_1 r-profvis=0.3.7=r41h06615bd_1 r-progress=1.2.2=r41hc72bb7e_3 r-promises=1.2.0.1=r41h7525677_1 r-ps=1.7.1=r41h06615bd_1 r-purrr=0.3.5=r41h06615bd_1 r-r6=2.5.1=r41hc72bb7e_1 r-ragg=1.2.4=r41hc1f6985_0 r-rappdirs=0.3.3=r41h06615bd_1 r-rcmdcheck=1.4.0=r41h785f33e_1 r-rcolorbrewer=1.1_3=r41h785f33e_1 r-rcpp=1.0.9=r41h7525677_2 r-rcurl=1.98_1.9=r41h06615bd_1 r-rematch2=2.1.2=r41hc72bb7e_2 r-remotes=2.4.2=r41hc72bb7e_1 r-restfulr=0.0.15=r41h73dbb54_0 r-rjson=0.2.21=r41h7525677_2 r-rlang=1.0.6=r41h7525677_1 r-rmarkdown=2.17=r41hc72bb7e_1 r-roxygen2=7.2.1=r41h7525677_1 r-rprojroot=2.0.3=r41hc72bb7e_1 r-rsqlite=2.2.18=r41h7525677_0 r-rstudioapi=0.14=r41hc72bb7e_1 r-rversions=2.1.2=r41hc72bb7e_1 r-sass=0.4.2=r41h7525677_1 r-scales=1.2.1=r41hc72bb7e_1 r-sessioninfo=1.2.2=r41hc72bb7e_1 r-shiny=1.7.3=r41h785f33e_0 r-snow=0.4_4=r41hc72bb7e_1 r-sourcetools=0.1.7=r41h7525677_1003 r-stringi=1.7.6=r41h337692f_1 r-stringr=1.4.1=r41hc72bb7e_1 r-sys=3.4.1=r41h06615bd_0 r-systemfonts=1.0.4=r41h0ff29ef_1 r-testthat=3.1.5=r41h7525677_1 r-textshaping=0.3.6=r41ha32badf_1 r-tibble=3.1.8=r41h06615bd_1 r-tidyselect=1.2.0=r41hc72bb7e_0 r-tinytex=0.42=r41hc72bb7e_1 r-urlchecker=1.0.1=r41hc72bb7e_1 r-usethis=2.1.6=r41hc72bb7e_1 r-utf8=1.2.2=r41h06615bd_1 r-vctrs=0.5.0=r41h7525677_0 r-viridislite=0.4.1=r41hc72bb7e_1 r-waldo=0.4.0=r41hc72bb7e_1 r-whisker=0.4=r41hc72bb7e_2 r-withr=2.5.0=r41hc72bb7e_1 r-xfun=0.34=r41h7525677_0 r-xml=3.99_0.9=r41h06615bd_0 r-xml2=1.3.3=r41h03ef668_0 r-xopen=1.0.0=r41hc72bb7e_1004 r-xtable=1.8_4=r41hc72bb7e_4 r-yaml=2.3.6=r41h06615bd_0 r-zip=2.2.1=r41h06615bd_1 ratelimiter=1.2.0=py_1002 re2=2022.06.01=h27087fc_0 readline=8.1=h46c0cb4_0 requests=2.28.1=pyhd8ed1ab_1 reretry=0.11.1=pyhd8ed1ab_0 riboWaltz@v1.2.0 rich=12.6.0=pyhd8ed1ab_0 rsa=4.9=pyhd8ed1ab_0 s3transfer=0.6.0=pyhd8ed1ab_0 samtools=1.14=hb421002_0 scikit-learn=1.1.2=py310h0c3af53_0 scipy=1.9.3=py310hdfbd76f_0 seaborn=0.12.1=hd8ed1ab_0 seaborn-base=0.12.1=pyhd8ed1ab_0 sed=4.8=he412f7d_0 setuptools=65.5.0=pyhd8ed1ab_0 setuptools-scm=7.0.5=pyhd8ed1ab_1 simplejson=3.17.6=py310h5764c6d_2 six=1.16.0=pyh6c4a22f_0 slacker=0.14.0=py_0 smart_open=6.2.0=pyha770c72_0 smmap=3.0.5=pyh44b312d_0 snakemake=7.16.0=hdfd78af_0 snakemake-minimal=7.16.0=pyhdfd78af_0 sqlite=3.37.0=h9cd32fc_0 statsmodels=0.13.2=py310hde88566_0 stone=3.3.1=pyhd8ed1ab_0 stopit=1.1.2=py_0 svt-av1=0.9.1=h27087fc_0 sysroot_linux-64=2.12=he073ed8_15 tabulate=0.9.0=pyhd8ed1ab_1 tbb=2021.6.0=h924138e_0 threadpoolctl=3.1.0=pyh8a188c0_0 tinycss2=1.2.1=pyhd8ed1ab_0 tk=8.6.12=h27826a3_0 tktable=2.10=hb7b940f_3 tomli=2.0.1=pyhd8ed1ab_0 toposort=1.7=pyhd8ed1ab_0 tornado=6.2=py310h5764c6d_1 traitlets=5.5.0=pyhd8ed1ab_0 typing-extensions=4.4.0=hd8ed1ab_0 typing_extensions=4.4.0=pyha770c72_0 tzdata=2022e=h191b570_0 ubiquerg=0.6.2=pyhd8ed1ab_0 unicodedata2=14.0.0=py310h5764c6d_1 uritemplate=4.1.1=pyhd8ed1ab_0 urllib3=1.26.11=pyhd8ed1ab_0 veracitools=0.1.3=py_0 vim=8.2.3901=py310pl5321hbf488a4_0 wcwidth=0.2.5=pyh9f0ad1d_2 webencodings=0.5.1=py_1 wget=1.20.3=ha56f1ee_1 wheel=0.37.1=pyhd8ed1ab_0 wrapt=1.14.1=py310h5764c6d_0 x264=1!161.3030=h7f98852_1 x265=3.5=h924138e_3 xopen=1.6.0=py310hff52083_0 xorg-fixesproto=5.0=h7f98852_1002 xorg-inputproto=2.3.2=h7f98852_1002 xorg-kbproto=1.0.7=h7f98852_1002 xorg-libice=1.0.10=h7f98852_0 xorg-libsm=1.2.3=hd9c2040_1000 xorg-libx11=1.7.2=h7f98852_0 xorg-libxau=1.0.9=h7f98852_0 xorg-libxdmcp=1.1.3=h7f98852_0 xorg-libxext=1.3.4=h7f98852_1 xorg-libxfixes=5.0.3=h7f98852_1004 xorg-libxi=1.7.10=h7f98852_0 xorg-libxrender=0.9.10=h7f98852_1003 xorg-libxt=1.2.1=h7f98852_2 xorg-renderproto=0.11.1=h7f98852_1002 xorg-xextproto=7.3.0=h7f98852_1002 xorg-xproto=7.0.31=h7f98852_1007 xz=5.2.6=h166bdaf_0 yaml=0.2.5=h7f98852_2 yarl=1.7.2=py310h5764c6d_2 yte=1.5.1=py310hff52083_0 zipp=3.10.0=pyhd8ed1ab_0 zlib=1.2.13=h166bdaf_4 zstd=1.5.2=h6239696_4","title":"Dependencies"},{"location":"dependencies.html#programs-and-dependencies","text":"_libgcc_mutex=0.1=conda_forge _openmp_mutex=4.5=2_gnu _r-mutex=1.0.1=anacondar_1 aioeasywebdav=2.4.0=pyha770c72_0 aiohttp=3.8.3=py310h5764c6d_0 aiosignal=1.2.0=pyhd8ed1ab_0 alsa-lib=1.2.3.2=h166bdaf_0 amply=0.1.5=pyhd8ed1ab_0 aom=3.3.0=h27087fc_1 appdirs=1.4.4=pyh9f0ad1d_0 argcomplete=2.0.0=pyhd8ed1ab_0 argh=0.26.2=pyh9f0ad1d_1002 async-timeout=4.0.2=pyhd8ed1ab_0 atk-1.0=2.36.0=h3371d22_4 attmap=0.13.2=pyhd8ed1ab_0 attrs=22.1.0=pyh71513ae_1 backports=1.0=py_2 backports.functools_lru_cache=1.6.4=pyhd8ed1ab_0 bcrypt=3.2.2=py310h5764c6d_0 binutils_impl_linux-64=2.39=h6ceecb4_0 binutils_linux-64=2.39=h5fc0e48_11 bioconductor-annotationdbi=1.56.2=r41hdfd78af_0 bioconductor-biobase=2.54.0=r41hc0cfd56_2 bioconductor-biocfilecache=2.2.0=r41hdfd78af_0 bioconductor-biocgenerics=0.40.0=r41hdfd78af_0 bioconductor-biocio=1.4.0=r41hdfd78af_0 bioconductor-biocparallel=1.28.3=r41hc247a5b_1 bioconductor-biomart=2.50.0=r41hdfd78af_0 bioconductor-biostrings=2.62.0=r41hc0cfd56_2 bioconductor-delayedarray=0.20.0=r41hc0cfd56_2 bioconductor-genomeinfodb=1.30.1=r41hdfd78af_0 bioconductor-genomeinfodbdata=1.2.6=r41hdfd78af_0 bioconductor-genomicalignments=1.30.0=r41hc0cfd56_2 bioconductor-genomicfeatures=1.46.1=r41hdfd78af_0 bioconductor-genomicranges=1.46.1=r41hc0cfd56_1 bioconductor-iranges=2.28.0=r41hc0cfd56_2 bioconductor-keggrest=1.34.0=r41hdfd78af_0 bioconductor-matrixgenerics=1.6.0=r41hdfd78af_0 bioconductor-rhtslib=1.26.0=r41hc0cfd56_2 bioconductor-rsamtools=2.10.0=r41hc247a5b_2 bioconductor-rtracklayer=1.54.0=r41h171f361_4 bioconductor-s4vectors=0.32.4=r41hc0cfd56_0 bioconductor-summarizedexperiment=1.24.0=r41hdfd78af_0 bioconductor-xvector=0.34.0=r41hc0cfd56_2 bioconductor-zlibbioc=1.40.0=r41hc0cfd56_2 biopython=1.79=py310h5764c6d_2 blast=2.13.0=hf3cf87c_0 boto3=1.25.1=pyhd8ed1ab_0 botocore=1.28.1=pyhd8ed1ab_0 bowtie2=2.4.5=py310h8d7afc0_4 brotli=1.0.9=h166bdaf_8 brotli-bin=1.0.9=h166bdaf_8 brotlipy=0.7.0=py310h5764c6d_1005 bwidget=1.9.14=ha770c72_1 bzip2=1.0.8=h7f98852_4 c-ares=1.18.1=h7f98852_0 ca-certificates=2022.9.24=ha878542_0 cachetools=5.2.0=pyhd8ed1ab_0 cairo=1.16.0=ha12eb4b_1010 cairocffi=1.3.0=pyhd8ed1ab_0 cairosvg=2.5.2=pyhd8ed1ab_0 certifi=2022.9.24=pyhd8ed1ab_0 cffi=1.15.1=py310h255011f_2 charset-normalizer=2.1.1=pyhd8ed1ab_0 coin-or-cbc=2.10.8=h3786ebc_0 coin-or-cgl=0.60.6=h6f57e76_1 coin-or-clp=1.17.7=h256e9bb_0 coin-or-osi=0.108.7=h2720bb7_2 coin-or-utils=2.11.6=h202d8b1_2 coincbc=2.10.8=0_metapackage commonmark=0.9.1=py_0 configargparse=1.5.3=pyhd8ed1ab_0 connection_pool=0.0.3=pyhd3deb0d_0 contourpy=1.0.5=py310hbf28c38_0 cryptography=38.0.2=py310h597c629_1 cssselect2=0.2.1=pyh9f0ad1d_1 curl=7.86.0=h7bff187_0 cutadapt=4.1=py310h1425a21_1 cycler=0.11.0=pyhd8ed1ab_0 dataclasses=0.8=pyhc8e2a94_3 datrie=0.8.2=py310h6acc77f_3 dbus=1.13.6=h5008d03_3 defusedxml=0.7.1=pyhd8ed1ab_0 dendropy=4.5.2=pyh3252c3a_0 dnaio=0.9.1=py310h1425a21_1 docutils=0.19=py310hff52083_1 dpath=2.0.6=py310hff52083_1 dropbox=11.35.0=pyhd8ed1ab_0 entrez-direct=16.2=he881be0_1 ete3=3.1.2=pyh9f0ad1d_0 exceptiongroup=1.0.0rc9=pyhd8ed1ab_0 expat=2.5.0=h27087fc_0 fastqc=0.11.9=hdfd78af_1 ffmpeg=4.4.1=hd7ab26d_2 filechunkio=1.8=py_2 filelock=3.8.0=pyhd8ed1ab_0 font-ttf-dejavu-sans-mono=2.37=hab24e00_0 font-ttf-inconsolata=3.000=h77eed37_0 font-ttf-source-code-pro=2.038=h77eed37_0 font-ttf-ubuntu=0.83=hab24e00_0 fontconfig=2.14.1=hc2a2eb6_0 fonts-conda-ecosystem=1=0 fonts-conda-forge=1=0 fonttools=4.38.0=py310h5764c6d_0 freeglut=3.2.2=h9c3ff4c_1 freetype=2.12.1=hca18f0e_0 fribidi=1.0.10=h36c2ea0_0 frozenlist=1.3.1=py310h5764c6d_1 ftputil=5.0.4=pyhd8ed1ab_0 future=0.18.2=pyhd8ed1ab_6 gawk=5.1.0=h7f98852_0 gcc_impl_linux-64=9.5.0=h99780fb_19 gcc_linux-64=9.5.0=h4258300_11 gdk-pixbuf=2.42.8=hff1cb4f_1 gettext=0.21.1=h27087fc_0 gffread=0.12.7=hd03093a_1 gffutils=0.11.1=pyh7cba7a3_0 gfortran_impl_linux-64=9.5.0=hf1096a2_19 gfortran_linux-64=9.5.0=hdb51d14_11 giflib=5.2.1=h36c2ea0_2 gitdb=4.0.9=pyhd8ed1ab_0 gitpython=3.1.29=pyhd8ed1ab_0 gmp=6.2.1=h58526e2_0 gnutls=3.6.13=h85f3911_1 google-api-core=2.10.1=pyhd8ed1ab_0 google-api-python-client=2.65.0=pyhd8ed1ab_0 google-auth=2.13.0=pyh1a96a4e_0 google-auth-httplib2=0.1.0=pyhd8ed1ab_1 google-cloud-core=2.3.2=pyhd8ed1ab_0 google-cloud-storage=2.5.0=pyh6c4a22f_0 google-crc32c=1.1.2=py310he8fe98e_3 google-resumable-media=2.4.0=pyhd8ed1ab_0 googleapis-common-protos=1.56.4=py310hff52083_0 graphite2=1.3.13=h58526e2_1001 graphviz=3.0.0=h5abf519_1 grpc-cpp=1.48.1=hbad87ad_1 grpcio=1.48.1=py310h946def9_1 gsl=2.7=he838d99_0 gst-plugins-base=1.18.5=hf529b03_3 gstreamer=1.18.5=h9f60fe5_3 gtk2=2.24.33=h90689f9_2 gts=0.7.6=h64030ff_2 gxx_impl_linux-64=9.5.0=h99780fb_19 gxx_linux-64=9.5.0=h43f449f_11 harfbuzz=4.2.0=h40b6f09_0 hdf5=1.12.1=nompi_h2386368_104 hisat2=2.2.1=h87f3376_4 htslib=1.14=h9753748_2 httplib2=0.20.4=pyhd8ed1ab_0 icu=69.1=h9c3ff4c_0 idna=3.4=pyhd8ed1ab_0 importlib-metadata=4.11.4=py310hff52083_0 importlib_metadata=4.11.4=hd8ed1ab_0 importlib_resources=5.10.0=pyhd8ed1ab_0 iniconfig=1.1.1=pyh9f0ad1d_0 isa-l=2.30.0=ha770c72_4 jasper=2.0.33=ha77e612_0 jinja2=3.1.2=pyhd8ed1ab_1 jmespath=1.0.1=pyhd8ed1ab_0 joblib=1.2.0=pyhd8ed1ab_0 jpeg=9e=h166bdaf_2 jsonschema=4.16.0=pyhd8ed1ab_0 jupyter_core=4.11.1=py310hff52083_0 kernel-headers_linux-64=2.6.32=he073ed8_15 keyutils=1.6.1=h166bdaf_0 kiwisolver=1.4.4=py310hbf28c38_0 krb5=1.19.3=h3790be6_0 lame=3.100=h166bdaf_1003 lcms2=2.12=hddcbb42_0 ld_impl_linux-64=2.39=hc81fddc_0 lerc=3.0=h9c3ff4c_0 libabseil=20220623.0=cxx17_h48a1fff_4 libblas=3.9.0=16_linux64_openblas libbrotlicommon=1.0.9=h166bdaf_8 libbrotlidec=1.0.9=h166bdaf_8 libbrotlienc=1.0.9=h166bdaf_8 libcblas=3.9.0=16_linux64_openblas libclang=13.0.1=default_hc23dcda_0 libcrc32c=1.1.2=h9c3ff4c_0 libcurl=7.86.0=h7bff187_0 libdeflate=1.10=h7f98852_0 libdrm=2.4.113=h166bdaf_0 libedit=3.1.20191231=he28a2e2_2 libev=4.33=h516909a_1 libevent=2.1.10=h9b69904_4 libffi=3.4.2=h7f98852_5 libgcc-devel_linux-64=9.5.0=h0a57e50_19 libgcc-ng=12.2.0=h65d4601_19 libgd=2.3.3=h283352f_2 libgfortran-ng=12.2.0=h69a702a_19 libgfortran5=12.2.0=h337968e_19 libgit2=1.5.0=h6529ace_0 libglib=2.74.1=h7a41b64_0 libglu=9.0.0=he1b5a44_1001 libgomp=12.2.0=h65d4601_19 libiconv=1.17=h166bdaf_0 libidn2=2.3.4=h166bdaf_0 liblapack=3.9.0=16_linux64_openblas liblapacke=3.9.0=16_linux64_openblas libllvm13=13.0.1=hf817b99_2 libnghttp2=1.47.0=hdcd2b5c_1 libnsl=2.0.0=h7f98852_0 libogg=1.3.4=h7f98852_1 libopenblas=0.3.21=pthreads_h78a6416_3 libopencv=4.5.5=py310hc83fb77_10 libopus=1.3.1=h7f98852_1 libpciaccess=0.16=h516909a_0 libpng=1.6.38=h753d276_0 libpq=14.3=hd77ab85_0 libprotobuf=3.20.1=h6239696_4 librsvg=2.52.5=h0a9e6e8_3 libsanitizer=9.5.0=h2f262e1_19 libsodium=1.0.18=h36c2ea0_1 libssh2=1.10.0=haa6b8db_3 libstdcxx-devel_linux-64=9.5.0=h0a57e50_19 libstdcxx-ng=12.2.0=h46fd767_19 libtiff=4.4.0=h0fcbabc_0 libtool=2.4.6=h9c3ff4c_1008 libunistring=0.9.10=h7f98852_0 libuuid=2.32.1=h7f98852_1000 libva=2.16.0=h166bdaf_0 libvorbis=1.3.7=h9c3ff4c_0 libvpx=1.11.0=h9c3ff4c_3 libwebp=1.2.4=h522a892_0 libwebp-base=1.2.4=h166bdaf_0 libxcb=1.13=h7f98852_1004 libxkbcommon=1.0.3=he3ba5ed_0 libxml2=2.9.12=h885dcf4_1 libxslt=1.1.33=h0ef7038_3 libzlib=1.2.13=h166bdaf_4 lightgbm=3.3.3=py310hd8f1fbe_0 logmuse=0.2.6=pyh8c360ce_0 lxml=4.8.0=py310h5764c6d_2 make=4.3=hd18ef5c_1 markupsafe=2.1.1=py310h5764c6d_2 matplotlib=3.6.0=py310hff52083_0 matplotlib-base=3.6.0=py310h8d5ebf3_0 multidict=6.0.2=py310h5764c6d_1 munkres=1.1.4=pyh9f0ad1d_0 mysql-common=8.0.31=haf5c9bc_0 mysql-libs=8.0.31=h28c427c_0 nano=2.9.8=hddfc1eb_1001 nbformat=5.7.0=pyhd8ed1ab_0 ncurses=6.2=h58526e2_4 nettle=3.6=he412f7d_0 nspr=4.32=h9c3ff4c_1 nss=3.74=hb5efdd6_0 numpy=1.23.4=py310h53a5b5f_1 oauth2client=4.1.3=py_0 openh264=2.1.1=h780b84a_0 openjdk=11.0.1=h516909a_1016 openjpeg=2.5.0=h7d73246_1 openssl=1.1.1s=h166bdaf_0 packaging=21.3=pyhd8ed1ab_0 pandas=1.5.1=py310h769672d_0 pandoc=2.19.2=h32600fe_1 pango=1.50.7=hbd2fdc8_0 paramiko=2.11.0=pyhd8ed1ab_0 patsy=0.5.3=pyhd8ed1ab_0 pbzip2=1.1.13=0 pcre=8.45=h9c3ff4c_0 pcre2=10.37=hc3806b6_1 peppy=0.35.2=pyhd8ed1ab_0 perl=5.32.1=2_h7f98852_perl5 perl-archive-tar=2.40=pl5321hdfd78af_0 perl-carp=1.50=pl5321hd8ed1ab_0 perl-common-sense=3.75=pl5321hd8ed1ab_0 perl-compress-raw-bzip2=2.201=pl5321h166bdaf_0 perl-compress-raw-zlib=2.202=pl5321h166bdaf_0 perl-encode=3.19=pl5321h166bdaf_0 perl-exporter=5.74=pl5321hd8ed1ab_0 perl-exporter-tiny=1.002002=pl5321hd8ed1ab_0 perl-extutils-makemaker=7.64=pl5321hd8ed1ab_0 perl-io-compress=2.201=pl5321h87f3376_0 perl-io-zlib=1.11=pl5321hdfd78af_0 perl-json=4.10=pl5321hdfd78af_0 perl-json-xs=2.34=pl5321h9f5acd7_5 perl-list-moreutils=0.430=pl5321hdfd78af_0 perl-list-moreutils-xs=0.430=pl5321hec16e2b_1 perl-parent=0.238=pl5321hd8ed1ab_0 perl-pathtools=3.75=pl5321h166bdaf_0 perl-scalar-list-utils=1.63=pl5321h166bdaf_0 perl-storable=3.15=pl5321h166bdaf_0 perl-types-serialiser=1.01=pl5321hdfd78af_0 pigz=2.6=h27826a3_0 pillow=9.2.0=py310hbd86126_2 pip=22.3=pyhd8ed1ab_0 pixman=0.40.0=h36c2ea0_0 pkgutil-resolve-name=1.3.10=pyhd8ed1ab_0 plac=1.3.5=pyhd8ed1ab_0 pluggy=1.0.0=py310hff52083_4 ply=3.11=py_1 prettytable=3.4.1=pyhd8ed1ab_0 protobuf=3.20.1=py310hd8f1fbe_0 psutil=5.9.3=py310h5764c6d_1 pthread-stubs=0.4=h36c2ea0_1001 pulp=2.6.0=py310hff52083_1 py-opencv=4.5.5=py310hfdc917e_10 pyasn1=0.4.8=py_0 pyasn1-modules=0.2.7=py_0 pycparser=2.21=pyhd8ed1ab_0 pyfaidx=0.7.1=pyh5e36f6f_0 pygments=2.13.0=pyhd8ed1ab_0 pynacl=1.5.0=py310h5764c6d_1 pyopenssl=22.1.0=pyhd8ed1ab_0 pyparsing=3.0.9=pyhd8ed1ab_0 pyqt=5.12.3=py310hff52083_8 pyqt-impl=5.12.3=py310h1f8e252_8 pyqt5-sip=4.19.18=py310h122e73d_8 pyqtchart=5.12=py310hfcd6d55_8 pyqtwebengine=5.12.1=py310hfcd6d55_8 pyrsistent=0.18.1=py310h5764c6d_2 pysam=0.19.1=py310hd89ff4b_0 pysftp=0.2.9=py_1 pysocks=1.7.1=pyha2e5f31_6 pytest=7.2.0=py310hff52083_0 python=3.10.2=h62f1059_0_cpython python-dateutil=2.8.2=pyhd8ed1ab_0 python-fastjsonschema=2.16.2=pyhd8ed1ab_0 python-irodsclient=1.1.5=pyhd8ed1ab_0 python-isal=1.1.0=py310h5764c6d_0 python_abi=3.10=2_cp310 pytz=2022.5=pyhd8ed1ab_0 pyu2f=0.1.5=pyhd8ed1ab_0 pyvcf3=1.0.3=pyhdfd78af_0 pyyaml=6.0=py310h5764c6d_5 qt=5.12.9=ha98a1a1_5 r-askpass=1.1=r41h06615bd_3 r-assertthat=0.2.1=r41hc72bb7e_3 r-backports=1.4.1=r41h06615bd_1 r-base=4.1.2=h2553ce4_1 r-base64enc=0.1_3=r41h06615bd_1005 r-bh=1.78.0_0=r41hc72bb7e_1 r-bit=4.0.4=r41h06615bd_1 r-bit64=4.0.5=r41h06615bd_1 r-bitops=1.0_7=r41h06615bd_1 r-blob=1.2.3=r41hc72bb7e_1 r-brew=1.0_8=r41hc72bb7e_1 r-brio=1.1.3=r41h06615bd_1 r-bslib=0.4.0=r41hc72bb7e_1 r-cachem=1.0.6=r41h06615bd_1 r-callr=3.7.2=r41hc72bb7e_1 r-cli=3.4.1=r41h7525677_1 r-clipr=0.8.0=r41hc72bb7e_1 r-colorspace=2.0_3=r41h06615bd_1 r-commonmark=1.8.1=r41h06615bd_0 r-cpp11=0.4.3=r41hc72bb7e_0 r-crayon=1.5.2=r41hc72bb7e_1 r-credentials=1.3.2=r41hc72bb7e_1 r-curl=4.3.3=r41h06615bd_1 r-data.table=1.14.4=r41h06615bd_0 r-dbi=1.1.3=r41hc72bb7e_1 r-dbplyr=2.2.1=r41hc72bb7e_1 r-desc=1.4.2=r41hc72bb7e_1 r-devtools=2.4.5=r41hc72bb7e_1 r-diffobj=0.3.5=r41h06615bd_1 r-digest=0.6.30=r41h7525677_0 r-downlit=0.4.2=r41hc72bb7e_1 r-dplyr=1.0.10=r41h7525677_1 r-ellipsis=0.3.2=r41h06615bd_1 r-evaluate=0.17=r41hc72bb7e_1 r-fansi=1.0.3=r41h06615bd_1 r-farver=2.1.1=r41h7525677_1 r-fastmap=1.1.0=r41h7525677_1 r-filelock=1.0.2=r41h06615bd_1003 r-fontawesome=0.4.0=r41hc72bb7e_0 r-formatr=1.12=r41hc72bb7e_1 r-fs=1.5.2=r41h7525677_2 r-futile.logger=1.4.3=r41hc72bb7e_1004 r-futile.options=1.0.1=r41hc72bb7e_1003 r-generics=0.1.3=r41hc72bb7e_1 r-gert=1.5.0=r41h163148b_3 r-ggplot2=3.3.6=r41hc72bb7e_1 r-ggrepel=0.9.1=r41h7525677_1 r-gh=1.3.1=r41hc72bb7e_1 r-gitcreds=0.1.2=r41hc72bb7e_1 r-glue=1.6.2=r41h06615bd_1 r-gtable=0.3.1=r41hc72bb7e_1 r-highr=0.9=r41hc72bb7e_1 r-hms=1.1.2=r41hc72bb7e_1 r-htmltools=0.5.3=r41h7525677_1 r-htmlwidgets=1.5.4=r41hc72bb7e_1 r-httpuv=1.6.6=r41h7525677_1 r-httr=1.4.4=r41hc72bb7e_1 r-ini=0.3.1=r41hc72bb7e_1004 r-isoband=0.2.6=r41h7525677_1 r-jquerylib=0.1.4=r41hc72bb7e_1 r-jsonlite=1.8.3=r41h06615bd_0 r-knitr=1.40=r41hc72bb7e_1 r-labeling=0.4.2=r41hc72bb7e_2 r-lambda.r=1.2.4=r41hc72bb7e_2 r-later=1.2.0=r41h7525677_1 r-lattice=0.20_45=r41h06615bd_1 r-lifecycle=1.0.3=r41hc72bb7e_1 r-magrittr=2.0.3=r41h06615bd_1 r-mass=7.3_58.1=r41h06615bd_1 r-matrix=1.5_1=r41h5f7b363_0 r-matrixstats=0.62.0=r41h06615bd_1 r-memoise=2.0.1=r41hc72bb7e_1 r-mgcv=1.8_41=r41h5f7b363_0 r-mime=0.12=r41h06615bd_1 r-miniui=0.1.1.1=r41hc72bb7e_1003 r-munsell=0.5.0=r41hc72bb7e_1005 r-nlme=3.1_160=r41h8da6f51_0 r-openssl=2.0.4=r41hfaab4ff_0 r-pillar=1.8.1=r41hc72bb7e_1 r-pkgbuild=1.3.1=r41hc72bb7e_1 r-pkgconfig=2.0.3=r41hc72bb7e_2 r-pkgdown=2.0.6=r41hc72bb7e_1 r-pkgload=1.3.0=r41hc72bb7e_1 r-plogr=0.2.0=r41hc72bb7e_1004 r-png=0.1_7=r41h06615bd_1005 r-praise=1.0.0=r41hc72bb7e_1006 r-prettyunits=1.1.1=r41hc72bb7e_2 r-processx=3.7.0=r41h06615bd_1 r-profvis=0.3.7=r41h06615bd_1 r-progress=1.2.2=r41hc72bb7e_3 r-promises=1.2.0.1=r41h7525677_1 r-ps=1.7.1=r41h06615bd_1 r-purrr=0.3.5=r41h06615bd_1 r-r6=2.5.1=r41hc72bb7e_1 r-ragg=1.2.4=r41hc1f6985_0 r-rappdirs=0.3.3=r41h06615bd_1 r-rcmdcheck=1.4.0=r41h785f33e_1 r-rcolorbrewer=1.1_3=r41h785f33e_1 r-rcpp=1.0.9=r41h7525677_2 r-rcurl=1.98_1.9=r41h06615bd_1 r-rematch2=2.1.2=r41hc72bb7e_2 r-remotes=2.4.2=r41hc72bb7e_1 r-restfulr=0.0.15=r41h73dbb54_0 r-rjson=0.2.21=r41h7525677_2 r-rlang=1.0.6=r41h7525677_1 r-rmarkdown=2.17=r41hc72bb7e_1 r-roxygen2=7.2.1=r41h7525677_1 r-rprojroot=2.0.3=r41hc72bb7e_1 r-rsqlite=2.2.18=r41h7525677_0 r-rstudioapi=0.14=r41hc72bb7e_1 r-rversions=2.1.2=r41hc72bb7e_1 r-sass=0.4.2=r41h7525677_1 r-scales=1.2.1=r41hc72bb7e_1 r-sessioninfo=1.2.2=r41hc72bb7e_1 r-shiny=1.7.3=r41h785f33e_0 r-snow=0.4_4=r41hc72bb7e_1 r-sourcetools=0.1.7=r41h7525677_1003 r-stringi=1.7.6=r41h337692f_1 r-stringr=1.4.1=r41hc72bb7e_1 r-sys=3.4.1=r41h06615bd_0 r-systemfonts=1.0.4=r41h0ff29ef_1 r-testthat=3.1.5=r41h7525677_1 r-textshaping=0.3.6=r41ha32badf_1 r-tibble=3.1.8=r41h06615bd_1 r-tidyselect=1.2.0=r41hc72bb7e_0 r-tinytex=0.42=r41hc72bb7e_1 r-urlchecker=1.0.1=r41hc72bb7e_1 r-usethis=2.1.6=r41hc72bb7e_1 r-utf8=1.2.2=r41h06615bd_1 r-vctrs=0.5.0=r41h7525677_0 r-viridislite=0.4.1=r41hc72bb7e_1 r-waldo=0.4.0=r41hc72bb7e_1 r-whisker=0.4=r41hc72bb7e_2 r-withr=2.5.0=r41hc72bb7e_1 r-xfun=0.34=r41h7525677_0 r-xml=3.99_0.9=r41h06615bd_0 r-xml2=1.3.3=r41h03ef668_0 r-xopen=1.0.0=r41hc72bb7e_1004 r-xtable=1.8_4=r41hc72bb7e_4 r-yaml=2.3.6=r41h06615bd_0 r-zip=2.2.1=r41h06615bd_1 ratelimiter=1.2.0=py_1002 re2=2022.06.01=h27087fc_0 readline=8.1=h46c0cb4_0 requests=2.28.1=pyhd8ed1ab_1 reretry=0.11.1=pyhd8ed1ab_0 riboWaltz@v1.2.0 rich=12.6.0=pyhd8ed1ab_0 rsa=4.9=pyhd8ed1ab_0 s3transfer=0.6.0=pyhd8ed1ab_0 samtools=1.14=hb421002_0 scikit-learn=1.1.2=py310h0c3af53_0 scipy=1.9.3=py310hdfbd76f_0 seaborn=0.12.1=hd8ed1ab_0 seaborn-base=0.12.1=pyhd8ed1ab_0 sed=4.8=he412f7d_0 setuptools=65.5.0=pyhd8ed1ab_0 setuptools-scm=7.0.5=pyhd8ed1ab_1 simplejson=3.17.6=py310h5764c6d_2 six=1.16.0=pyh6c4a22f_0 slacker=0.14.0=py_0 smart_open=6.2.0=pyha770c72_0 smmap=3.0.5=pyh44b312d_0 snakemake=7.16.0=hdfd78af_0 snakemake-minimal=7.16.0=pyhdfd78af_0 sqlite=3.37.0=h9cd32fc_0 statsmodels=0.13.2=py310hde88566_0 stone=3.3.1=pyhd8ed1ab_0 stopit=1.1.2=py_0 svt-av1=0.9.1=h27087fc_0 sysroot_linux-64=2.12=he073ed8_15 tabulate=0.9.0=pyhd8ed1ab_1 tbb=2021.6.0=h924138e_0 threadpoolctl=3.1.0=pyh8a188c0_0 tinycss2=1.2.1=pyhd8ed1ab_0 tk=8.6.12=h27826a3_0 tktable=2.10=hb7b940f_3 tomli=2.0.1=pyhd8ed1ab_0 toposort=1.7=pyhd8ed1ab_0 tornado=6.2=py310h5764c6d_1 traitlets=5.5.0=pyhd8ed1ab_0 typing-extensions=4.4.0=hd8ed1ab_0 typing_extensions=4.4.0=pyha770c72_0 tzdata=2022e=h191b570_0 ubiquerg=0.6.2=pyhd8ed1ab_0 unicodedata2=14.0.0=py310h5764c6d_1 uritemplate=4.1.1=pyhd8ed1ab_0 urllib3=1.26.11=pyhd8ed1ab_0 veracitools=0.1.3=py_0 vim=8.2.3901=py310pl5321hbf488a4_0 wcwidth=0.2.5=pyh9f0ad1d_2 webencodings=0.5.1=py_1 wget=1.20.3=ha56f1ee_1 wheel=0.37.1=pyhd8ed1ab_0 wrapt=1.14.1=py310h5764c6d_0 x264=1!161.3030=h7f98852_1 x265=3.5=h924138e_3 xopen=1.6.0=py310hff52083_0 xorg-fixesproto=5.0=h7f98852_1002 xorg-inputproto=2.3.2=h7f98852_1002 xorg-kbproto=1.0.7=h7f98852_1002 xorg-libice=1.0.10=h7f98852_0 xorg-libsm=1.2.3=hd9c2040_1000 xorg-libx11=1.7.2=h7f98852_0 xorg-libxau=1.0.9=h7f98852_0 xorg-libxdmcp=1.1.3=h7f98852_0 xorg-libxext=1.3.4=h7f98852_1 xorg-libxfixes=5.0.3=h7f98852_1004 xorg-libxi=1.7.10=h7f98852_0 xorg-libxrender=0.9.10=h7f98852_1003 xorg-libxt=1.2.1=h7f98852_2 xorg-renderproto=0.11.1=h7f98852_1002 xorg-xextproto=7.3.0=h7f98852_1002 xorg-xproto=7.0.31=h7f98852_1007 xz=5.2.6=h166bdaf_0 yaml=0.2.5=h7f98852_2 yarl=1.7.2=py310h5764c6d_2 yte=1.5.1=py310hff52083_0 zipp=3.10.0=pyhd8ed1ab_0 zlib=1.2.13=h166bdaf_4 zstd=1.5.2=h6239696_4","title":"Programs and Dependencies"},{"location":"orfdate_inputs.html","text":"ORFdate input files # ORFdate takes as input files: a distance phylogenetic tree in newick format, containing the species of interest (focal species) and its neighbors (see ORFmine/examples/database/orfdate_inputs/ for an example). All branches must be associated with their relative distance on which the age estimation will be based. a two columns csv file (i.e. columns separated by commas) with the path to the sequence fasta files of each species as first column, and the associated species names as indicated in the phylogenetic tree as second column (see ORFmine/examples/database/orfdate_inputs/ for an example). It, therefore, involves the fasta files of the complete proteomes (amino acid sequences) of the focal and its neighbors to be stored in the corresponding directories. the fasta files containing all the amino acid sequences of the focal and its neighboring species. All these files must be stored directly or in a subdirectory of the /database/ directory of the container (see here for more details on the preparation of the folders of the container).","title":"Inputs"},{"location":"orfdate_inputs.html#orfdate-input-files","text":"ORFdate takes as input files: a distance phylogenetic tree in newick format, containing the species of interest (focal species) and its neighbors (see ORFmine/examples/database/orfdate_inputs/ for an example). All branches must be associated with their relative distance on which the age estimation will be based. a two columns csv file (i.e. columns separated by commas) with the path to the sequence fasta files of each species as first column, and the associated species names as indicated in the phylogenetic tree as second column (see ORFmine/examples/database/orfdate_inputs/ for an example). It, therefore, involves the fasta files of the complete proteomes (amino acid sequences) of the focal and its neighbors to be stored in the corresponding directories. the fasta files containing all the amino acid sequences of the focal and its neighboring species. All these files must be stored directly or in a subdirectory of the /database/ directory of the container (see here for more details on the preparation of the folders of the container).","title":"ORFdate input files"},{"location":"orfdate_objectives.html","text":"Aims and general description of ORFdate # ORFdate estimates the evolutionary age (in Mya) of a set of ORFs of a genome (coding or noncoding ORFs) based on phylostratigraphy.","title":"Objectives"},{"location":"orfdate_objectives.html#aims-and-general-description-of-orfdate","text":"ORFdate estimates the evolutionary age (in Mya) of a set of ORFs of a genome (coding or noncoding ORFs) based on phylostratigraphy.","title":"Aims and general description of ORFdate"},{"location":"orfdate_outputs.html","text":"ORFdate outputs: # ORFdate generates two outputs in csv format located in the /workdir/orfdate/ directory. Examples of these outputs can be found in the ORFmine/exmaples/workdir/orfdate/ folder. *_hits.csv which reports the number of significant matches for all sequences of the focal species (rows) across the neighbors species of the tree (columns) *_dated.csv which reports for each sequence (col 1), the farest neighbor species for which a significant math has been found (col2), and the time of divergence between this neighbor and the focal species in Mya (col3) with \"*\" being the basename of the focal fasta file. ORFdate generates intermediate files (blast databases and blast outputs) which are stored in the /workdir/orfdate/blast_database/ and /workdir/orfdate/blast_out/ directories. Examples of such outputs can be found in the ORFmine/examples/workdir/orfdate/ directory.","title":"Outputs"},{"location":"orfdate_outputs.html#orfdate-outputs","text":"ORFdate generates two outputs in csv format located in the /workdir/orfdate/ directory. Examples of these outputs can be found in the ORFmine/exmaples/workdir/orfdate/ folder. *_hits.csv which reports the number of significant matches for all sequences of the focal species (rows) across the neighbors species of the tree (columns) *_dated.csv which reports for each sequence (col 1), the farest neighbor species for which a significant math has been found (col2), and the time of divergence between this neighbor and the focal species in Mya (col3) with \"*\" being the basename of the focal fasta file. ORFdate generates intermediate files (blast databases and blast outputs) which are stored in the /workdir/orfdate/blast_database/ and /workdir/orfdate/blast_out/ directories. Examples of such outputs can be found in the ORFmine/examples/workdir/orfdate/ directory.","title":"ORFdate outputs:"},{"location":"orfdate_overview.html","text":"","title":"Orfdate overview"},{"location":"orfdate_parameters.html","text":"ORFdate parameters # Mandatory -focal FOCAL taxonomic name of the focal species -names NAMES csv file matching fasta (col1) and tree (col2) names -tree TREE newick file for the phylogeny tree Optional -h, --help show this help message and exit -ncpus NCPUS total number of cpus that can be used fo the task (default: 1) -evalue EVALUE BLASTp evalue threshold (default: 1e-3) -query_cov QUERY_COV minimum query coverage threshold (default: 0.70) -preserve_underscores PRESERVE_UNDERSCORES (default: False). If True, the underscores that are present in the species names in the tree and csv file are considered explicitly and not replaced by spaces. Usually underscoeres in the tree labels are replaced by spaces. Usefull when the species name contains underscores (e.g. Scer_annotationV2).","title":"Parameters"},{"location":"orfdate_parameters.html#orfdate-parameters","text":"Mandatory -focal FOCAL taxonomic name of the focal species -names NAMES csv file matching fasta (col1) and tree (col2) names -tree TREE newick file for the phylogeny tree Optional -h, --help show this help message and exit -ncpus NCPUS total number of cpus that can be used fo the task (default: 1) -evalue EVALUE BLASTp evalue threshold (default: 1e-3) -query_cov QUERY_COV minimum query coverage threshold (default: 0.70) -preserve_underscores PRESERVE_UNDERSCORES (default: False). If True, the underscores that are present in the species names in the tree and csv file are considered explicitly and not replaced by spaces. Usually underscoeres in the tree labels are replaced by spaces. Usefull when the species name contains underscores (e.g. Scer_annotationV2).","title":"ORFdate parameters"},{"location":"orfdate_run.html","text":"Running ORFdate # ORFdate estimates the evolutionary ages of a set of ORFs (coding but also noncoding) based on phylostratigraphy. It takes as inputs: a phylogenetic distance tree in newick format, containing the species of interest (focal species) and its neighbors a two column csv file (i.e. columns separated by commas) with the path to the sequence fasta files of each species as first column, and the associated species names as indicated in the phylogenetic tree as second column. It, therefore, involves the fasta files of the complete proteomes (amino acid sequences) of the focal and its neighbors to be stored in the corresponding directories the fasta files containing all the amino acid sequences of the focal and its neighboring species All the inputs must be stored in the /database/ directory of the container, though a subdirectory can be created for more clarity (e.g. /database/orfdate_inputs/). The following command line will estimate the ages of all sequences present in the fasta file of the focal species (be they coding or noncoding) based on the phylogenetic tree provided by the user (an example of the different inputs can be found in ORFmine/examples/database/orfdate_inputs/). orfdate -focal focal_name -tree /database/orfdate_inputs/species_tree.nwk -names /database/orfdate_inputs/names.csv with the -focal option corresponding to the name of the focal name as indicated in the tree; -tree option corresponding to the distance tree (newick format) of the focal and its neighbors and -names option corresponding to the two column csv file with the path/filenames of the fasta files and the corresponding species names. Please note that additional arguments including BLAST parameters can be provided. See here for more details.","title":"Run"},{"location":"orfdate_run.html#running-orfdate","text":"ORFdate estimates the evolutionary ages of a set of ORFs (coding but also noncoding) based on phylostratigraphy. It takes as inputs: a phylogenetic distance tree in newick format, containing the species of interest (focal species) and its neighbors a two column csv file (i.e. columns separated by commas) with the path to the sequence fasta files of each species as first column, and the associated species names as indicated in the phylogenetic tree as second column. It, therefore, involves the fasta files of the complete proteomes (amino acid sequences) of the focal and its neighbors to be stored in the corresponding directories the fasta files containing all the amino acid sequences of the focal and its neighboring species All the inputs must be stored in the /database/ directory of the container, though a subdirectory can be created for more clarity (e.g. /database/orfdate_inputs/). The following command line will estimate the ages of all sequences present in the fasta file of the focal species (be they coding or noncoding) based on the phylogenetic tree provided by the user (an example of the different inputs can be found in ORFmine/examples/database/orfdate_inputs/). orfdate -focal focal_name -tree /database/orfdate_inputs/species_tree.nwk -names /database/orfdate_inputs/names.csv with the -focal option corresponding to the name of the focal name as indicated in the tree; -tree option corresponding to the distance tree (newick format) of the focal and its neighbors and -names option corresponding to the two column csv file with the path/filenames of the fasta files and the corresponding species names. Please note that additional arguments including BLAST parameters can be provided. See here for more details.","title":"Running ORFdate"},{"location":"orfget_param.html","text":"ORFget parameters # Mandatory -fna nucleotide fasta file of the genome whose ORFs are to extract -gff gff annotation file Optional -h, --help shows this help message and exits -features_include genomic features or annotation patterns to be searched for the ORF selection. ORFs whose annotations match the entered patterns or genomic features are written in the output fasta file. (default: all genomic features present in the input gff, consequently, all annotated ORFs will be written in the output gff file)(see the ORFget section for more details). -features_exclude genomic features or annotation patterns to be searched for the ORF selection. ORFs whose annotations match the entered patterns or genomic features are not written in the output fasta file. (default: None, consequently, all annotated ORFs will be written in the output gff file)(see the ORFget section for more details). -chr_exclude to exclude a (or a subset of) seqID(s) for the ORF extraction and writing - the ORFs belonging to this seqID (usually a chromosome or a contig) will not be written in the output fasta file no matter their annotation category (default: None). -N number of ORFs randomly selected for the writing according to their genomic feature or pattern.","title":"ORFget parameters"},{"location":"orfget_param.html#orfget-parameters","text":"Mandatory -fna nucleotide fasta file of the genome whose ORFs are to extract -gff gff annotation file Optional -h, --help shows this help message and exits -features_include genomic features or annotation patterns to be searched for the ORF selection. ORFs whose annotations match the entered patterns or genomic features are written in the output fasta file. (default: all genomic features present in the input gff, consequently, all annotated ORFs will be written in the output gff file)(see the ORFget section for more details). -features_exclude genomic features or annotation patterns to be searched for the ORF selection. ORFs whose annotations match the entered patterns or genomic features are not written in the output fasta file. (default: None, consequently, all annotated ORFs will be written in the output gff file)(see the ORFget section for more details). -chr_exclude to exclude a (or a subset of) seqID(s) for the ORF extraction and writing - the ORFs belonging to this seqID (usually a chromosome or a contig) will not be written in the output fasta file no matter their annotation category (default: None). -N number of ORFs randomly selected for the writing according to their genomic feature or pattern.","title":"ORFget parameters"},{"location":"orfget_run.html","text":"Extraction and writing of ORF sequences with ORFget # ORFget is a tool provided with ORFtrack that allows the user to extract the protein and/or nulceotide sequences of specific subsets of ORFs according to their annotation categories (see here for a description of all ORF categories). ORFget deals with annotation patterns, thereby allowing different levels of annotation in a very easy fashion. ORFget has two principal options: -features_include : list of motifs that will be used to define the ORFs that will be included in the fasta output. The sequences whose annotations include these patterns will be retained in the output fasta file -features_exclude : list of motifs that will be used to define the ORFs that will be excluded in the fasta output. The sequences whose annotations include these patterns will not be written in the output fasta file The searched patterns can be specific (for a finer selection) or more general. Note For example, the motif \"nc\" which refers to all NonCoding ORFs appears in the features: nc _intergenic, nc _ovp_same-mRNA, nc _ovp_opp-mRNA and nc _ovp_same-tRNA. As a result, the option -feature_include nc will keep all the four feature categories. The option -feature_include nc_ovp will keep: nc_ovp _same-mRNA nc_ovp _opp-mRNA nc_ovp _same-tRNA The option -feature_include nc_ovp_same will keep: nc_ovp_same -mRNA nc_ovp_same -tRNA The option -feature_include mRNA will keep: nc_ovp_same- mRNA nc_ovp_opp- mRNA The option -feature_exclude opp will eliminate the nc_ovp_ opp -mRNA and will keep: nc_intergenic nc_ovp_same-mRNA nc_ovp_same-tRNA etc... Here are presented some examples of selection of ORFs with ORFget. Extraction of the sequences of all the ORFs of a GFF file # The following command writes the amino acid sequences of all the ORFs of the gff file annotated by ORFtrack. orfget -fna /database/genome.fasta -gff /database/mapping_orf_genome.gff ORFget generates a fasta file containing all the corresponding amino acid sequences. The output fasta file is written in the /database/ directory of the container. Note It can also handle gff files that were not generated by ORFtrack but in this case the user must be sure of the feature names to be indicated if using the -feature_include/exclude options. In this case, the features must correspond to those indicated in the 3rd column of the input gff file. Extraction of the sequences of all noncoding ORFs identified with ORFtrack # The following commands, each enable the user to write the amino acid sequences of all noncoding ORFs no matter their status (i.e. intergenic or overlapping) (see here for a description of all ORF categories). orfget -fna /database/genome.fasta -gff /database/mapping_orf_genome.gff -features_include nc or orfget -fna /database/genome.fasta -gff /database/mapping_orf_genome.gff -features_include nc_intergenic nc_ovp or orfget -fna /database/genome.fasta -gff /database/mapping_orf_genome.gff -features_exclude c_CDS The output fasta file is written in the /database/ directory of the container and renamed based on the gff file rootname and the include features. Extraction of the sequences of a specific subset of ORFs according to their annotation # The following instruction writes the amino acid sequences of the ORFs which overlap CDSs on the same, or on the opposite strand. orfget -fna /database/genome.fasta -gff /database/mapping_orf_genome.gff -features_include nc_ovp_same-CDS nc_ovp_opp-CDS Notice that using the argument \"features_exclude\" assumes that the selection operates on all genomic features except those that are excluded. Consequently, if the user wants to select all noncoding sequences except those overlapping CDSs, mRNAs, tRNAs, and rRNAs, he/she must exclude the coding ORFs (c_CDS) as well. Otherwise, they will be kept. orfget -fna genome.fasta -gff mapping_orf_genome.gff -features_exclude c_CDS nc_same_ovp-tRNA nc_same_ovp-rRNA nc_opp_ovp-mRNA nc_opp_ovp-tRNA nc_opp_ovp-rRNA nc_opp_ovp-mRNA The output fasta file is written in the /database/ directory of the container and renamed based on the gff file rootname and the include features. Extraction of the sequences of a random subset of ORFs # Sometimes, for computational time or storage reasons, the user does not want to deal with all the ORFs of a specific category. ORFget can provide the user with a subset of N (to be defined by the user) randomly selected ORFs from a specific ORF category. The last instruction writes the sequences of 10000 randomly selected noncoding intergenic ORFs. orfget -fna /database/genome.fasta -gff /database/mapping_orf_genome.gff -features_include nc_intergenic -n 10000 Reconstruction of protein sequences # In addition, ORFget enables the reconstruction of all protein sequences of a genome (including all isoforms) according to their definition in the original gff file. The following instruction writes all the resulting sequences in a fasta file. Please note that in this case, the input gff file is the initial one, not the one generated by ORFtrack which is ORF-centered and that contains C_CDS ORFs instead of the exact CDSs (i.e. ATG-STOP including isoforms) as indicated in the original gff file. orfget -fna /database/genome.fasta -gff /database/genome.gff -features_include CDS Writing amino acid or nucleotide sequences # By default, ORFget will generate the amino acid sequences of the desired ORFs in a fasta file with the extension .pfasta . If the user wishes to generate the nucleotide or even both nucleotide and amino acids sequences, he/she must use the option -type nucl and -type both , respectively.","title":"ORF extraction with ORFget"},{"location":"orfget_run.html#extraction-and-writing-of-orf-sequences-with-orfget","text":"ORFget is a tool provided with ORFtrack that allows the user to extract the protein and/or nulceotide sequences of specific subsets of ORFs according to their annotation categories (see here for a description of all ORF categories). ORFget deals with annotation patterns, thereby allowing different levels of annotation in a very easy fashion. ORFget has two principal options: -features_include : list of motifs that will be used to define the ORFs that will be included in the fasta output. The sequences whose annotations include these patterns will be retained in the output fasta file -features_exclude : list of motifs that will be used to define the ORFs that will be excluded in the fasta output. The sequences whose annotations include these patterns will not be written in the output fasta file The searched patterns can be specific (for a finer selection) or more general. Note For example, the motif \"nc\" which refers to all NonCoding ORFs appears in the features: nc _intergenic, nc _ovp_same-mRNA, nc _ovp_opp-mRNA and nc _ovp_same-tRNA. As a result, the option -feature_include nc will keep all the four feature categories. The option -feature_include nc_ovp will keep: nc_ovp _same-mRNA nc_ovp _opp-mRNA nc_ovp _same-tRNA The option -feature_include nc_ovp_same will keep: nc_ovp_same -mRNA nc_ovp_same -tRNA The option -feature_include mRNA will keep: nc_ovp_same- mRNA nc_ovp_opp- mRNA The option -feature_exclude opp will eliminate the nc_ovp_ opp -mRNA and will keep: nc_intergenic nc_ovp_same-mRNA nc_ovp_same-tRNA etc... Here are presented some examples of selection of ORFs with ORFget.","title":"Extraction and writing of ORF sequences with ORFget"},{"location":"orfget_run.html#extraction-of-the-sequences-of-all-the-orfs-of-a-gff-file","text":"The following command writes the amino acid sequences of all the ORFs of the gff file annotated by ORFtrack. orfget -fna /database/genome.fasta -gff /database/mapping_orf_genome.gff ORFget generates a fasta file containing all the corresponding amino acid sequences. The output fasta file is written in the /database/ directory of the container. Note It can also handle gff files that were not generated by ORFtrack but in this case the user must be sure of the feature names to be indicated if using the -feature_include/exclude options. In this case, the features must correspond to those indicated in the 3rd column of the input gff file.","title":"Extraction of the sequences of all the ORFs of a GFF file"},{"location":"orfget_run.html#extraction-of-the-sequences-of-all-noncoding-orfs-identified-with-orftrack","text":"The following commands, each enable the user to write the amino acid sequences of all noncoding ORFs no matter their status (i.e. intergenic or overlapping) (see here for a description of all ORF categories). orfget -fna /database/genome.fasta -gff /database/mapping_orf_genome.gff -features_include nc or orfget -fna /database/genome.fasta -gff /database/mapping_orf_genome.gff -features_include nc_intergenic nc_ovp or orfget -fna /database/genome.fasta -gff /database/mapping_orf_genome.gff -features_exclude c_CDS The output fasta file is written in the /database/ directory of the container and renamed based on the gff file rootname and the include features.","title":"Extraction of the sequences of all noncoding ORFs identified with ORFtrack"},{"location":"orfget_run.html#extraction-of-the-sequences-of-a-specific-subset-of-orfs-according-to-their-annotation","text":"The following instruction writes the amino acid sequences of the ORFs which overlap CDSs on the same, or on the opposite strand. orfget -fna /database/genome.fasta -gff /database/mapping_orf_genome.gff -features_include nc_ovp_same-CDS nc_ovp_opp-CDS Notice that using the argument \"features_exclude\" assumes that the selection operates on all genomic features except those that are excluded. Consequently, if the user wants to select all noncoding sequences except those overlapping CDSs, mRNAs, tRNAs, and rRNAs, he/she must exclude the coding ORFs (c_CDS) as well. Otherwise, they will be kept. orfget -fna genome.fasta -gff mapping_orf_genome.gff -features_exclude c_CDS nc_same_ovp-tRNA nc_same_ovp-rRNA nc_opp_ovp-mRNA nc_opp_ovp-tRNA nc_opp_ovp-rRNA nc_opp_ovp-mRNA The output fasta file is written in the /database/ directory of the container and renamed based on the gff file rootname and the include features.","title":"Extraction of the sequences of a specific subset of ORFs according to their annotation"},{"location":"orfget_run.html#extraction-of-the-sequences-of-a-random-subset-of-orfs","text":"Sometimes, for computational time or storage reasons, the user does not want to deal with all the ORFs of a specific category. ORFget can provide the user with a subset of N (to be defined by the user) randomly selected ORFs from a specific ORF category. The last instruction writes the sequences of 10000 randomly selected noncoding intergenic ORFs. orfget -fna /database/genome.fasta -gff /database/mapping_orf_genome.gff -features_include nc_intergenic -n 10000","title":"Extraction of the sequences of a random subset of ORFs"},{"location":"orfget_run.html#reconstruction-of-protein-sequences","text":"In addition, ORFget enables the reconstruction of all protein sequences of a genome (including all isoforms) according to their definition in the original gff file. The following instruction writes all the resulting sequences in a fasta file. Please note that in this case, the input gff file is the initial one, not the one generated by ORFtrack which is ORF-centered and that contains C_CDS ORFs instead of the exact CDSs (i.e. ATG-STOP including isoforms) as indicated in the original gff file. orfget -fna /database/genome.fasta -gff /database/genome.gff -features_include CDS","title":"Reconstruction of protein sequences"},{"location":"orfget_run.html#writing-amino-acid-or-nucleotide-sequences","text":"By default, ORFget will generate the amino acid sequences of the desired ORFs in a fasta file with the extension .pfasta . If the user wishes to generate the nucleotide or even both nucleotide and amino acids sequences, he/she must use the option -type nucl and -type both , respectively.","title":"Writing amino acid or nucleotide sequences"},{"location":"orfmine_binding.html","text":"Binding the local folders to the container # When creating your container with the singularity or docker commands, the folders you have prepared on your local machine are linked to the folders already created inside the container through the -B or -v arguments (for singularity or docker respectively). The paths of the local and container folders are separated with a colon as follows: /path/on/your/local/machine/:/corresponding/path/inside/the/container Pleae note that you must indicate the complete path of your local folder, not its parent folder. workdir (mandatory): /path/of/your/local/working/folder/ to be linked to /workdir/ This is needed everytime you start the container since it links your working directory with that of the container (named \"workdir\"). /path/of/your/local/working/folder/:/workdir/ database (mandatory): /path/of/your/data/folder/ to be linked to /database/ This is needed everytime you start the container since it links the folder containing your data (gff, fasta files...) to the \"database\" folder of the container. /path/of/your/local/data/folder/:/database/ fastq (only if you use ORFribo): /path/of/your/local/fastq/folder/ to be linked to /fastq/ Needed when using ORFribo in order to indicate where the Ribosome Profilng data (i.e. fastq.gz files) are stored. This folder will be linked to the \"fastq\" folder of the container. /path/of/your/local/fastq/folder/:/fastq/ Examples: Let's say all the genome sequence and annotation files are stored in a directory named \"Genomes\" and located in the \"/home/ProjectXYZ/\" directory. This will be indicated in the singularity or docker command lines through the -B/-v argument (depending on the use of docker (-v) or singularity (-B) respectively) as follows: -v /home/ProjectXYZ/Genomes/:/database/ for docker -B /home/ProjectXYZ/Genomes/:/database/ for singularity If the Ribosome Profiling fastq files are stored in the folder \"WT_vs_Mutant\" located in the \"/home/Ribosome-profiling/October2022/\" directory, it will be indicated in the singularity or docker command lines as follows: -v /home/Ribosome-profiling/October2022/WT_vs_Mutant/:/fastq/ for docker -B /home/Ribosome-profiling/October2022/WT_vs_Mutant/:/fastq/ for singularity Examples of the comlete command line can be found here .","title":"Orfmine binding"},{"location":"orfmine_binding.html#binding-the-local-folders-to-the-container","text":"When creating your container with the singularity or docker commands, the folders you have prepared on your local machine are linked to the folders already created inside the container through the -B or -v arguments (for singularity or docker respectively). The paths of the local and container folders are separated with a colon as follows: /path/on/your/local/machine/:/corresponding/path/inside/the/container Pleae note that you must indicate the complete path of your local folder, not its parent folder. workdir (mandatory): /path/of/your/local/working/folder/ to be linked to /workdir/ This is needed everytime you start the container since it links your working directory with that of the container (named \"workdir\"). /path/of/your/local/working/folder/:/workdir/ database (mandatory): /path/of/your/data/folder/ to be linked to /database/ This is needed everytime you start the container since it links the folder containing your data (gff, fasta files...) to the \"database\" folder of the container. /path/of/your/local/data/folder/:/database/ fastq (only if you use ORFribo): /path/of/your/local/fastq/folder/ to be linked to /fastq/ Needed when using ORFribo in order to indicate where the Ribosome Profilng data (i.e. fastq.gz files) are stored. This folder will be linked to the \"fastq\" folder of the container. /path/of/your/local/fastq/folder/:/fastq/ Examples: Let's say all the genome sequence and annotation files are stored in a directory named \"Genomes\" and located in the \"/home/ProjectXYZ/\" directory. This will be indicated in the singularity or docker command lines through the -B/-v argument (depending on the use of docker (-v) or singularity (-B) respectively) as follows: -v /home/ProjectXYZ/Genomes/:/database/ for docker -B /home/ProjectXYZ/Genomes/:/database/ for singularity If the Ribosome Profiling fastq files are stored in the folder \"WT_vs_Mutant\" located in the \"/home/Ribosome-profiling/October2022/\" directory, it will be indicated in the singularity or docker command lines as follows: -v /home/Ribosome-profiling/October2022/WT_vs_Mutant/:/fastq/ for docker -B /home/Ribosome-profiling/October2022/WT_vs_Mutant/:/fastq/ for singularity Examples of the comlete command line can be found here .","title":"Binding the local folders to the container"},{"location":"orfmine_citations.html","text":"How to cite us and others # If you use only ORFtrack # please cite: Papadopoulos, C., Chevrollier, N., Lopes, A. Exploring the peptide potential of genomes. Meth. Mol. Biol. (2022). If you use only ORFfold with HCA, IUPred and Tango # please cite: Papadopoulos, C., Chevrollier, N., Lopes, A. Exploring the peptide potential of genomes. Meth. Mol. Biol. (2022) Bitard-Feildel, T. & Callebaut, I. HCAtk and pyHCA: A Toolkit and Python API for the Hydrophobic Cluster Analysis of Protein Sequences. bioRxiv 249995 (2018). Me\u0301sza\u0301ros, B., Erdo\u030bs, G. & Doszta\u0301nyi, Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46, W329\u2013W337 (2018). Linding, R., Schymkowitz, J., Rousseau, F., Diella, F. & Serrano, L. A comparative study of the relationship between protein structure and \u03b2-aggregation in globular and intrinsically disordered proteins. Journal of molecular biology 342, 345\u2013353 (2004). Otherwise, if you use ORFold with a combination of HCA, IUPred and Tango # please cite: Papadopoulos, C., Chevrollier, N., Lopes, A. Exploring the peptide potential of genomes. Meth. Mol. Biol. (2022) and the publications corresponding to your calculations: for HCA, cite: Bitard-Feildel, T. & Callebaut, I. HCAtk and pyHCA: A Toolkit and Python API for the Hydrophobic Cluster Analysis of Protein Sequences. bioRxiv 249995 (2018). for IUPred, cite: Me\u0301sza\u0301ros, B., Erdo\u030bs, G. & Doszta\u0301nyi, Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46, W329\u2013W337 (2018). for Tango, cite: Linding, R., Schymkowitz, J., Rousseau, F., Diella, F. & Serrano, L. A comparative study of the relationship between protein structure and \u03b2-aggregation in globular and intrinsically disordered proteins. Journal of molecular biology 342, 345\u2013353 (2004). If you use ORFribo or ORFdate # please cite: Papadopoulos, C., Arbes, H., Chevrollier, N., Blanchet, S., Cornu, D., Roginski, P., Rabier, C., Atia, S., Lespinet, O., Namy, O., Lopes, A. (submitted).","title":"Citations"},{"location":"orfmine_citations.html#how-to-cite-us-and-others","text":"","title":"How to cite us and others"},{"location":"orfmine_citations.html#if-you-use-only-orftrack","text":"please cite: Papadopoulos, C., Chevrollier, N., Lopes, A. Exploring the peptide potential of genomes. Meth. Mol. Biol. (2022).","title":"If you use only ORFtrack"},{"location":"orfmine_citations.html#if-you-use-only-orffold-with-hca-iupred-and-tango","text":"please cite: Papadopoulos, C., Chevrollier, N., Lopes, A. Exploring the peptide potential of genomes. Meth. Mol. Biol. (2022) Bitard-Feildel, T. & Callebaut, I. HCAtk and pyHCA: A Toolkit and Python API for the Hydrophobic Cluster Analysis of Protein Sequences. bioRxiv 249995 (2018). Me\u0301sza\u0301ros, B., Erdo\u030bs, G. & Doszta\u0301nyi, Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46, W329\u2013W337 (2018). Linding, R., Schymkowitz, J., Rousseau, F., Diella, F. & Serrano, L. A comparative study of the relationship between protein structure and \u03b2-aggregation in globular and intrinsically disordered proteins. Journal of molecular biology 342, 345\u2013353 (2004).","title":"If you use only ORFfold with HCA, IUPred and Tango"},{"location":"orfmine_citations.html#otherwise-if-you-use-orfold-with-a-combination-of-hca-iupred-and-tango","text":"please cite: Papadopoulos, C., Chevrollier, N., Lopes, A. Exploring the peptide potential of genomes. Meth. Mol. Biol. (2022) and the publications corresponding to your calculations: for HCA, cite: Bitard-Feildel, T. & Callebaut, I. HCAtk and pyHCA: A Toolkit and Python API for the Hydrophobic Cluster Analysis of Protein Sequences. bioRxiv 249995 (2018). for IUPred, cite: Me\u0301sza\u0301ros, B., Erdo\u030bs, G. & Doszta\u0301nyi, Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46, W329\u2013W337 (2018). for Tango, cite: Linding, R., Schymkowitz, J., Rousseau, F., Diella, F. & Serrano, L. A comparative study of the relationship between protein structure and \u03b2-aggregation in globular and intrinsically disordered proteins. Journal of molecular biology 342, 345\u2013353 (2004).","title":"Otherwise, if you use ORFold with a combination of HCA, IUPred and Tango"},{"location":"orfmine_citations.html#if-you-use-orfribo-or-orfdate","text":"please cite: Papadopoulos, C., Arbes, H., Chevrollier, N., Blanchet, S., Cornu, D., Roginski, P., Rabier, C., Atia, S., Lespinet, O., Namy, O., Lopes, A. (submitted).","title":"If you use ORFribo or ORFdate"},{"location":"orfmine_installation.html","text":"Installation # Overview # ORFmine is a package that consists of different programs: ORFtrack, ORFribo, ORFold and ORFdate. They can be used together or independently with the exception of ORFribo, which needs the ORFtrack's output file as input to be functional. Requirements # First of all, Docker 1 or Singularity 2 must be present in order to get the image containing all the scripts and tools needed for the analysis. Singularity might be prefered as it does not need super user rights, which is interesting for the use of ORFmine on a cluster or on a lab's computer. Singularity installation for UNIX-based OS is explained here . Docker Engine is available on different OS like MacOS and Windows10 through Docker Desktop and as a static binary installation for a variety of Linux platforms (Docker Desktop for Linux is now available on some distributions). Everything is available here . Note For Windows, WSL2 and Ubuntu from Microsoft store applications usually are needed too. For reproducibility purposes, all programs and dependencies used by ORFmine are listed here . Pull the ORFmine docker image # All the scripts and tools needed for the analysis were put and installed in a docker image stored on Dockerhub. You can pull and use it from a terminal as a docker image by writing : docker pull annelopes94/orfmine:v0.8.7 or as a singularity image : # this will build a singularity image named orfmine_v0.8.7.sif that will be located in YOUR_PATH (to adapt) singularity build YOUR_PATH/orfmine_v0.8.6.sif docker://annelopes94/orfmine:v0.8.7 This step might take about 10-20 minutes depending on your computer. Note If you have any error, it might come from a permissions problem so you should try using these commands with sudo as prefix. The quick installation is now complete! Please have a look here to start your container. References # Merkel, Dirk. \"Docker: lightweight linux containers for consistent development and deployment.\" Linux j 239.2 (2014) Kurtzer GM, Sochat V, Bauer MW. Singularity: Scientific containers for mobility of compute. PLoS One. 2017;12(5):e0177459. Published 2017 May 11. doi:10.1371/journal.pone.0177459 Dosztanyi, Z., Csizmok, V., Tompa, P. & Simon, I. The pairwise energy content estimated from amino acid composition discriminates between folded and intrinsically unstructured proteins. Journal of molecular biology 347, 827\u2013839 (2005). Doszta\u0301nyi, Z. Prediction of protein disorder based on IUPred. Protein Science 27, 331\u2013 340 (2018). Me\u0301sza\u0301ros, B., Erdo\u030bs, G. & Doszta\u0301nyi, Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46, W329\u2013W337 (2018). Fernandez-Escamilla, A.-M., Rousseau, F., Schymkowitz, J. & Serrano, L. Prediction of sequence-dependent and mutational effects on the aggregation of peptides and proteins. Nature biotechnology 22, 1302\u20131306 (2004). Linding, R., Schymkowitz, J., Rousseau, F., Diella, F. & Serrano, L. A comparative study of the relationship between protein structure and \u03b2-aggregation in globular and intrinsically disordered proteins. Journal of molecular biology 342, 345\u2013353 (2004). Rousseau, F., Schymkowitz, J. & Serrano, L. Protein aggregation and amyloidosis: confusion of the kinds? Current opinion in structural biology 16, 118\u2013126 (2006).","title":"Installation"},{"location":"orfmine_installation.html#installation","text":"","title":"Installation"},{"location":"orfmine_installation.html#overview","text":"ORFmine is a package that consists of different programs: ORFtrack, ORFribo, ORFold and ORFdate. They can be used together or independently with the exception of ORFribo, which needs the ORFtrack's output file as input to be functional.","title":"Overview"},{"location":"orfmine_installation.html#requirements","text":"First of all, Docker 1 or Singularity 2 must be present in order to get the image containing all the scripts and tools needed for the analysis. Singularity might be prefered as it does not need super user rights, which is interesting for the use of ORFmine on a cluster or on a lab's computer. Singularity installation for UNIX-based OS is explained here . Docker Engine is available on different OS like MacOS and Windows10 through Docker Desktop and as a static binary installation for a variety of Linux platforms (Docker Desktop for Linux is now available on some distributions). Everything is available here . Note For Windows, WSL2 and Ubuntu from Microsoft store applications usually are needed too. For reproducibility purposes, all programs and dependencies used by ORFmine are listed here .","title":"Requirements"},{"location":"orfmine_installation.html#pull-the-orfmine-docker-image","text":"All the scripts and tools needed for the analysis were put and installed in a docker image stored on Dockerhub. You can pull and use it from a terminal as a docker image by writing : docker pull annelopes94/orfmine:v0.8.7 or as a singularity image : # this will build a singularity image named orfmine_v0.8.7.sif that will be located in YOUR_PATH (to adapt) singularity build YOUR_PATH/orfmine_v0.8.6.sif docker://annelopes94/orfmine:v0.8.7 This step might take about 10-20 minutes depending on your computer. Note If you have any error, it might come from a permissions problem so you should try using these commands with sudo as prefix. The quick installation is now complete! Please have a look here to start your container.","title":"Pull the ORFmine docker image"},{"location":"orfmine_installation.html#references","text":"Merkel, Dirk. \"Docker: lightweight linux containers for consistent development and deployment.\" Linux j 239.2 (2014) Kurtzer GM, Sochat V, Bauer MW. Singularity: Scientific containers for mobility of compute. PLoS One. 2017;12(5):e0177459. Published 2017 May 11. doi:10.1371/journal.pone.0177459 Dosztanyi, Z., Csizmok, V., Tompa, P. & Simon, I. The pairwise energy content estimated from amino acid composition discriminates between folded and intrinsically unstructured proteins. Journal of molecular biology 347, 827\u2013839 (2005). Doszta\u0301nyi, Z. Prediction of protein disorder based on IUPred. Protein Science 27, 331\u2013 340 (2018). Me\u0301sza\u0301ros, B., Erdo\u030bs, G. & Doszta\u0301nyi, Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46, W329\u2013W337 (2018). Fernandez-Escamilla, A.-M., Rousseau, F., Schymkowitz, J. & Serrano, L. Prediction of sequence-dependent and mutational effects on the aggregation of peptides and proteins. Nature biotechnology 22, 1302\u20131306 (2004). Linding, R., Schymkowitz, J., Rousseau, F., Diella, F. & Serrano, L. A comparative study of the relationship between protein structure and \u03b2-aggregation in globular and intrinsically disordered proteins. Journal of molecular biology 342, 345\u2013353 (2004). Rousseau, F., Schymkowitz, J. & Serrano, L. Protein aggregation and amyloidosis: confusion of the kinds? Current opinion in structural biology 16, 118\u2013126 (2006).","title":"References"},{"location":"orfmine_overview.html","text":"Overview of ORFmine # RECENT studies attribute a new role to the noncoding genome in the production of novel peptides. The widespread transcription of noncoding regions and the pervasive translation of the resulting RNAs offer a vast reservoir of novel peptides to the organisms. ORFmine is an open-source package that aims at extracting, annotating, and characterizing the fold potential and the structural properties of all Open Reading Frames (ORF) encoded in a genome (including coding and noncoding sequences). ORFmine consists of two independent programs, ORFtrack and ORFold that can be used together or independently (see here for an example of application). ORFtrack searches for all possible ORFs longer than 60 nucleotides in the six frames of an input genome, and annotate them according to a set of genomic features (e.g. noncoding intergenic ORFs, coding ORFs, noncoding ORFs that overlap with a specific genomic feature...). It provides the user with a GFF file containing the annotations of all identified ORFs that can be directly uploaded on a genome viewer for a visual inspection. In addition, their amino acid and/or nucleotide sequences can be extracted in a FASTA file (for more details, see the complete documentation of ORFtrack). ORFold probes the fold potential and the disorder and aggregation propensities of a set of amino acid sequences (all ORFs annotated by ORFtrack for example). The fold potential is estimated with the HCA method [1], while the disorder and aggregation propensities are calculated with IUPRred[2][3][4], and TANGO[5][6][7] respectively. The specificity of ORFold lies in the fact that the user can provide the amino acid sequences along with their corresponding annotations in a GFF file. In this case, ORFold produces new GFF files, each containing for each annotated sequence, their fold potential, disorder and aggregation propensities respectively, thereby enabling the manual inspection of these properties along a genome in a genome viewer (for more details, see the complete documentation of ORFold). References # Bitard-Feildel, T. & Callebaut, I. HCAtk and pyHCA: A Toolkit and Python API for the Hydrophobic Cluster Analysis of Protein Sequences. bioRxiv 249995 (2018). Dosztanyi, Z., Csizmok, V., Tompa, P. & Simon, I. The pairwise energy content estimated from amino acid composition discriminates between folded and intrinsically unstructured proteins. Journal of molecular biology 347, 827\u2013839 (2005). Doszta\u0301nyi, Z. Prediction of protein disorder based on IUPred. Protein Science 27, 331\u2013 340 (2018). Me\u0301sza\u0301ros, B., Erdo\u030bs, G. & Doszta\u0301nyi, Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46, W329\u2013W337 (2018). Fernandez-Escamilla, A.-M., Rousseau, F., Schymkowitz, J. & Serrano, L. Prediction of sequence-dependent and mutational effects on the aggregation of peptides and proteins. Nature biotechnology 22, 1302\u20131306 (2004). Linding, R., Schymkowitz, J., Rousseau, F., Diella, F. & Serrano, L. A comparative study of the relationship between protein structure and \u03b2-aggregation in globular and intrinsically disordered proteins. Journal of molecular biology 342, 345\u2013353 (2004). Rousseau, F., Schymkowitz, J. & Serrano, L. Protein aggregation and amyloidosis: confusion of the kinds? Current opinion in structural biology 16, 118\u2013126 (2006).","title":"Orfmine overview"},{"location":"orfmine_overview.html#overview-of-orfmine","text":"RECENT studies attribute a new role to the noncoding genome in the production of novel peptides. The widespread transcription of noncoding regions and the pervasive translation of the resulting RNAs offer a vast reservoir of novel peptides to the organisms. ORFmine is an open-source package that aims at extracting, annotating, and characterizing the fold potential and the structural properties of all Open Reading Frames (ORF) encoded in a genome (including coding and noncoding sequences). ORFmine consists of two independent programs, ORFtrack and ORFold that can be used together or independently (see here for an example of application). ORFtrack searches for all possible ORFs longer than 60 nucleotides in the six frames of an input genome, and annotate them according to a set of genomic features (e.g. noncoding intergenic ORFs, coding ORFs, noncoding ORFs that overlap with a specific genomic feature...). It provides the user with a GFF file containing the annotations of all identified ORFs that can be directly uploaded on a genome viewer for a visual inspection. In addition, their amino acid and/or nucleotide sequences can be extracted in a FASTA file (for more details, see the complete documentation of ORFtrack). ORFold probes the fold potential and the disorder and aggregation propensities of a set of amino acid sequences (all ORFs annotated by ORFtrack for example). The fold potential is estimated with the HCA method [1], while the disorder and aggregation propensities are calculated with IUPRred[2][3][4], and TANGO[5][6][7] respectively. The specificity of ORFold lies in the fact that the user can provide the amino acid sequences along with their corresponding annotations in a GFF file. In this case, ORFold produces new GFF files, each containing for each annotated sequence, their fold potential, disorder and aggregation propensities respectively, thereby enabling the manual inspection of these properties along a genome in a genome viewer (for more details, see the complete documentation of ORFold).","title":"Overview of ORFmine"},{"location":"orfmine_overview.html#references","text":"Bitard-Feildel, T. & Callebaut, I. HCAtk and pyHCA: A Toolkit and Python API for the Hydrophobic Cluster Analysis of Protein Sequences. bioRxiv 249995 (2018). Dosztanyi, Z., Csizmok, V., Tompa, P. & Simon, I. The pairwise energy content estimated from amino acid composition discriminates between folded and intrinsically unstructured proteins. Journal of molecular biology 347, 827\u2013839 (2005). Doszta\u0301nyi, Z. Prediction of protein disorder based on IUPred. Protein Science 27, 331\u2013 340 (2018). Me\u0301sza\u0301ros, B., Erdo\u030bs, G. & Doszta\u0301nyi, Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46, W329\u2013W337 (2018). Fernandez-Escamilla, A.-M., Rousseau, F., Schymkowitz, J. & Serrano, L. Prediction of sequence-dependent and mutational effects on the aggregation of peptides and proteins. Nature biotechnology 22, 1302\u20131306 (2004). Linding, R., Schymkowitz, J., Rousseau, F., Diella, F. & Serrano, L. A comparative study of the relationship between protein structure and \u03b2-aggregation in globular and intrinsically disordered proteins. Journal of molecular biology 342, 345\u2013353 (2004). Rousseau, F., Schymkowitz, J. & Serrano, L. Protein aggregation and amyloidosis: confusion of the kinds? Current opinion in structural biology 16, 118\u2013126 (2006).","title":"References"},{"location":"orfmine_quickstart.html","text":"Quick start # Here we first explain how to prepare the folders necessary for ORFmine and launch the container . In addition, are presented several examples of the use of the different programs of ORFmine: annotation and extraction of all the ORFs (coding and noncoding) of a genome with ORFtrack and its companion program ORFget prediction of the fold potential of all noncoding ORFs of a genome with ORFold characterization of the translation activity of all intergenic ORFs of a genome with ORFribo estimation of the ages of all the CDSs of a genome with ORFdate All the inputs used in these examples are available in the ORFmine/examples/ folder that can be dowloaded here . Prepare your directories # First, you need to prepare your directories (that will depend on the usage) with the appropriate data. These directories will then be bound to your container when launching the container, so that your data will be accessible to the ORFmine programs (see here for launching the container). Your future container will have the following architecture: / \u251c\u2500\u2500 database \u251c\u2500\u2500 fastq \u2514\u2500\u2500 workdir \u251c\u2500\u2500 orfdate \u251c\u2500\u2500 orfold \u2514\u2500\u2500 orfribo database directory (any usage) # Several files must be provided in order to run the different ORFmine programs. They need to be placed in the same directory whatever the programs to be used. This directory will then be bound to the /database directory of your future container. For ORFtrack: A fasta file with the reference genome sequence (e.g. genome.fa) A gff file with the reference genome annotation (e.g. genome.gff3) For ORFribo: A fasta file with the reference genome sequence (e.g. genome.fa) A gff file with the reference genome annotation (e.g. genome.gff3) A fasta file with the sequences you do not want to treat and that you want to remove from the mapping, usually rRNA sequences (e.g. outRNA.fa) For ORFold: A fasta file with the amino acid sequences to treat A gff file (optional) if you want to map the HCA, Tango or IUPred scores along the chromosome and to see them with a genome browser like IGV. For ORFdate: Fasta files of the complete proteomes (amino acid sequences) of the focal species and its neighbors The corresponding tree (nwk format) Table (2 columns) with the paths to the fasta files of proteomes and the names of the corresponding species More details are given in the corresponding sections. All these files whatever the programs you will run must be in the same local directory (though subdirectories can be created for more clarity but they must be in the same global directory) that will constitute the /database directory of the future container. You are free to choose the name and the path of the folder in your local machine. working directory (any usage) # When creating the container, please be aware that you will choose a directory that will be your working directory and where some of the outputs will be written. Particular case of ORFribo: The working directory must contain the configuration file called config.yaml , completed by the user (see here for more details on how to complete the config.yaml ). This directory will then be bound on the /workdir directory of your future container. You are free to choose the name and the path of the folder in your local machine. fastq directory (ORFribo) # If you want to use ORFribo, you must place the Ribosome Profiling data (i.e. the fastq(.gz) files) in a specific folder without anything else inside it . You can have this folder wherever you want on your computer and name it as you like. This directory will then be bound to the /fastq directory of your future container. Launch the container # To launch the container and get an interactive shell inside it, you can use either the \"singularity \" or the \"docker\" commands. Every folder that you have prepared before must be bound to their corresponding folders inside the container through the -v or -B options (see the command lines below). In the following command lines, every italics part has to be adapted from your computer's organization (names and paths) and the other parts are part of the container structure and must remain as they are! Using singularity singularity shell --pwd /workdir/ \\ -B PATH_TO_YOUR_WORKING_DIR :/workdir/ \\ -B PATH_TO_YOUR_DATA_DIR :/database/ \\ -B PATH_TO_YOUR_FASTQ_DIR :/fastq/ \\ PATH_TO_YOUR_ORFMINE_IMAGE .sif Using docker The same logic applies with the docker command except that absolute paths must be given: docker run --rm -it \\ -v ABSOLUTE_PATH_TO_YOUR_WORKING_DIR :/workdir/ \\ -v ABSOLUTE_PATH_TO_YOUR_DATA_DIR :/database/ \\ -v ABSOLUTE_PATH_TO_YOUR_FASTQ_DIR :/fastq/ \\ annelopes94/orfmine:v0.8.7 Please note that if you do not want to use ORFribo, you do not need to link the fastq folder to the container and can remove the binding part of the command line: PATH_TO_YOUR_FASTQ_DIR :/fastq/ . See here for more details on how to bind your local folders to those of the container. Binding Tango and/or IUPred # If you want to use Tango and/or IUPred with ORFfold, you will need to have those softwares installed on your local computer (choose the Unix compatible source code for Tango). Once installed, please place the parent directory content of those softwares inside a directory of your choice. Below is a description of the workflow we followed: # let's consider Tango is installed in ~\\tango and IUPred in ~/iupred2a # create a directory that will contain Tango and IUPred source codes content mkdir ~/softwares # place Tango and IUPred source codes content in softwares cp ~/tango ~/softwares cp -r ~/iupred2a/* ~/softwares To use Tango and/or IUPred on the container, you must launch your container by binding the directory created above to a specific directory on the container For singularity: singularity shell --pwd /workdir/ \\ -B PATH_TO_YOUR_WORKING_DIR :/workdir/ \\ -B PATH_TO_YOUR_DATA_DIR :/database/ \\ -B PATH_TO_YOUR_FASTQ_DIR :/fastq/ \\ -B PATH_TO_YOUR_DIR_CONTAINING_TANGO_OR_IUPRED :/ORFmine/orfold_v1/orfold/softwares/ \\ PATH_TO_YOUR_ORFMINE_IMAGE .sif For docker: docker run --rm -it \\ -v ABSOLUTE_PATH_TO_YOUR_WORKING_DIR :/workdir/ \\ -v ABSOLUTE_PATH_TO_YOUR_DATA_DIR :/database/ \\ -v ABSOLUTE_PATH_TO_YOUR_FASTQ_DIR :/fastq/ \\ -v ABSOLUTE_PATH_TO_YOUR_DIR_CONTAINING_TANGO_OR_IUPRED :/ORFmine/orfold_v1/orfold/softwares/ \\ annelopes94/orfmine:v0.8.7 Note When launching the container with docker, the annelopes94/orfmine:v0.8.7 part can be changed if you want to launch a specific version of ORFmine. For example : annelopes94/orfmine:v0.8.6 . If you do not know which versions you have on your computer, you can print them by typing docker image ls WARNING: please keep in mind that, once launched, you work inside the container. Filenames in the command lines must, therefore, be indicated either alone (i.e. without any path) or prefixed with the path of the folder as it is inside the container (i.e. path relative to the container not to your local machine - e.g. /database, /fastq, /workdir). For example, when running ORFold, the fasta filenames must be indicated in the command line as follows: orfold -faa sequences.fasta OR orfold -faa /database/sequences.fasta Again, do not indicate the path of the sequences.fasta file according to your local machine architecture - the container only refers to its relative paths. If you want autocompletion when writing the filenames, you need to precise the path of the folder containing the corresponding files (relative path according to the container). You can verify the content of your directories as follows: ls /workdir/ This should display all the files and folders of the working directory. Or : ls /database/ This should display all the files and folders of the data folder containing all the data files (fasta, gff, ...). Examples of ORFmine usage # To guide the user, all command line examples will rely on the examples directory that can be found here . If you want to follow the guidelines, please follow the procedure below: # place examples.zip on a directory and unzip it mkdir ~/orfmine_tutorial mv ~/Downloads/examples.zip ~/orfmine_tutorial cd ~/orfmine_tutorial/ unzip examples.zip cd examples/ # launch the container (docker usage case). docker run --rm -it -v $(pwd)/workdir:/workdir/ -v $(pwd)/database:/database/ -v $(pwd)/fastq:/fastq/ annelopes94/orfmine:v0.8.7 # or with singularity (considering your .sif image is there: ~/orfmine/orfmine_v0.8.7.sif) singularity shell --pwd /workdir/ -B workdir:/workdir/ -B database</i>:/database/ -B fastq</i>:/fastq/ ~/orfmine/orfmine_v0.8.7.sif After following this procedure, you could juste copy/paste all of the commands below to test them directly. Annotation and extraction of ORFs with ORFtrack # Annotation of ORFs # ORFtrack takes as input (i) a fasta file containing the nucleotide sequences of all chromosomes or contigs, and (ii) the corresponding annotations in a gff file (see the GFF3 documentation for more details on the GFF3 format). Please notice that we strongly recommend using GFF3 formats. The following command runs ORFtrack on the complete genome of Saccharomyces cerevisiae ( Scer ) available in the ORFmine/examples folder: orftrack -fna /database/Scer.fna -gff /database/Scer.gff ORFtrack generates a novel gff file mapping_orf_Scer.gff that contains the annotations of all the identified ORFs (see here for more details on the annotation process). The output file is located in /database/. Indeed, all the ORFtrack and ORFget outputs are stored in /database/ since they might constitute the inputs of the other ORFmine programs. A copy of the output can be found in the ORFmine/examples/database/ folder). Please note that ORFtrack also generates a summary.log file that lists all the ORF categories it has identified. Extraction of the sequences of noncoding ORFs in a fasta format # The amino acid sequences of all annotated ORFs or specific subsets of ORFs (i.e. only noncoding intergenic ORFs for example) can be extracted and written in a fasta file with ORFget, a tool provided with ORFtrack. The following instruction writes the amino acid sequences of all yeast noncoding ORFs (including noncoding intergenic ORFs and those that overlap with a genomic feature). ORFget therefore needs the genome sequence (nucleotides) from which the ORF sequences will be extracted and translated into amino acids and the ORFtrack output gff file with the annotations and coordinates of all the identified ORFs. The -features_include option indicates the features to be matched in the names of the ORFs that we want to extract. In this case, we are interested in all noncoding ORFs (i.e. all ORFs containing the flag \"nc\" - see here for more details on the annotation rules of the ORFs), so we indicate it to ORFget through the \"-features_include nc\" option (see here for more examples). orfget -fna /database/Scer.fna -gff /database/mapping_orf_Scer.gff -features_include nc ORFget produces a fasta file (mapping_orf_Scer_nc.pfasta) containing the amino acid sequences of all noncoding ORFs annotated by ORFtrack (see here for more examples on the use of ORFget).The output fasta is stored in /database/ directory of the container and renamed based on the gff file rootname and the include features. The user can also extract the nucleotide sequences through the \"-type\" option (-type nucl) or both amino acid and nucleotide sequences (-type both). Extraction of the sequences of the CDSs of yeast in a fasta format # In addition, ORFget enables the reconstruction of all coding sequences (CDSs) of the input genome (in this examlpe, Scer) according to their annotation in the original gff file. When different isoforms are described, it will generate all of them according to the gff file. It, therefore, needs as input the original gff file (not the one created by ORFtrack which only contains STOP-to-STOP ORFs) and the genome sequence in FASTA format. orfget -fna /database/Scer.fna -gff /database/Scer.gff -features_include CDS The output is generated in the /database/ directory of the container. An example of this output is available in the ORFmine/examples/database/ directory. Characterization of the fold potential and disorder and aggregation propensities of the noncoding ORFs with ORFold # Running ORFold # ORFold only needs a fasta file containing the amino acid sequences to characterize. In the following example, ORFold will estimate the foldability and the disorder and aggregation propensities of all the amino acid sequences potentially encoded in the noncoding ORFs of yeast. orfold -faa /database/mapping_orf_Scer_nc.pfasta -options H with -options H to indicate that we want to estimate the foldability (H for HCA). ORFold generates one table that is stored in the /workdir/orfold directory of the container (a copy of the output can be found in ORFmine/examples/workdir/orfold directory). The table contains for each input sequence, the fold potential as calculated by HCA [1] (see here for more details on the calculation of this score). In addition, a gff file containing the annotation of the input sequences can be provided as well. In this case, ORFold writes the fold potential and disorder and aggregation propensities in the 9th column of three gff files respectively. The latter can be subsequently uploaded on a genome viewer like IGV for a visual inspection of the distribution of these properties along the genome. The following instruction enables the user to probe the fold potential and disorder and aggregation propensities of all the yeast noncoding ORFs annotated by ORFtrack and takes as inputs the corresponding fasta file and the gff file generated by ORFtrack (mapping_orf_Scer.gff located in /database/). orfold -faa /database/mapping_orf_Scer_nc.pfasta -options H -gff /database/mapping_orf_Scer.gff In addition to the score table, ORFold has generated a new gff file containing for each ORF its fold potential. The output gff file is stored in the /workdir/orfold directory of the container and can be subsequently uploaded on a genome viewer. Visualization of the distribution of the fold potential with ORFplot # ORFplot enables the visualization of the distribution of the fold potential of the amino acid sequences potentially encoded in noncoding ORFs along with the one of a reference dataset of globular proteins taken from M\u00e9sz\u00e1ros et al. [2]. It takes as input the table generatd by ORFold that must be located in the /workdir/orfold/ directory of the container. orfplot -tab /workdir/orfold/mapping_orf_Scer_nc.tab -names \"Yeast noncoding ORFs\" The output graphic is generated in PNG and PDF formats and stored in the /workdir/orfold directory of the container (see here for other examples of use of ORFplot). Each distribution is compared with the one of the globular protein dataset with a Kolmogorov Smirnov test. Asterisks on the plot denote level of significance: * < 0.05, * * < 0.01, *** < 0.001. Characterization of the translation activity of all intergenic ORFs of yeast # ORFribo, based on ribosome-profiling data, probes the translation activity of all the ORFs of interest of a genome (be they coding or noncoding) that are annotated in a gff file. We strongly recommend using ORFtrack to generate the gff file since ORFtrack and ORFribo were jointly developed so that the output of ORFtrack fits the prerequisites of ORFribo. In this example, we investigate the translation of all intergenic ORFs of yeast annotated as \"nc_intergenic\" by ORFtrack in its output mapping_orf_Scer.gff. An example of this file that has been generated by ORFtrack and that will be used as input by ORFribo is available in the ORFmine/examples/database/ folder. Here is presented a simple example that enables one to run ORFribo from inputs and a pre-configurated config.yaml file which are all available in the ORFmine/examples/ folder. However, before running ORFribo on this example dataset, we recommend the user read in details the phylosophy and main steps of ORFribo. Input files # ORFribo relies on the fastq file(s) (Ribo-Seq dataset(s)) that must be stored in the /fastq/ folder of the container - an example of such file is available in the ORFmine/examples/fastq folder /fastq/XYZ.fastq and 4 additional files that must be stored in the /database/ folder of the container. Examples of such files are available in the ORFmine/examples/database/ folder. Scer.fna: fasta file containing the nucleotide sequences of the chromosomes of the yeast genome Scer.gff: the original annotation of yeast in a gff file mapping_orf_Scer.gff: the gff file containing all the ORFs detected by ORFtrack and including the nc_intergenic ORFs for which we want to estimate the translation activity. It therefore involves that you have previously generated this file as presented here Scer_rRNA.fa: A fasta file with the sequences that we want to remove from the mapping step, here rRNA sequences Preparing the config.yaml file # ORFribo is very easy to handle and only needs a configuration file to be edited before running it. The latter named config.yaml contains the parameters that can be adjusted by the user. The full description of this file is available here . For this example, a pre-filled configuration file is present is the ORFmine/examples/workdir/ directory. Please place the config.yaml file in the /workdir/ directory of your container and edit it if needed following the instructions presented here : Running ORFribo # The only parameters to adjust in the command line are: The number of virtual CPUs/threads to reserve for the analysis The approximate amount of memory to reserve for the analysis (in GB) ORFribo is launched like this: orfribo CPU MEMORY For example, for an analysis launched with the use of 6 CPUs and around 10GB of memory, it would be: orfribo 6 10 Be careful to have enough memory on your computer/cluster for you analysis as a lack of RAM would lead the pipeline to crash without giving any error message. So if the program stops without any obvious reason this might be the reason why, and one should restart the pipeline with more resources. Main outputs # ORFribo generates many intermediate files that can be useful for further analysis. Their description is available here . The main output is the table named genome_mean70_median70_reads_concatenated.tab that summarizes the results for each ORF of interest (e.g. nb and fractions of F0, F1 and F2 reads). An example of this output table can be found in the /workdir/orfribo/RESULTS/Bam2Reads_genome_output/SRR1520313_17031088/ directory. A full description of the summary table can be found here . Running ORFdate # ORFdate estimates the evolutionary ages of a set of ORFs (coding but also noncoding) based on phylostratigraphy. It takes as inputs: a distance phylogenetic tree in newick format, containing the species of interest (focal species) and its neighbors (see ORFmine/examples/database/orfdate_inputs/ for an example). All branches must be associated with their relative distance on which the age estimation will be based. a two columns csv file (i.e. columns separated by commas) with the path to the sequence fasta files of each species as first column, and the associated species names as indicated in the phylogenetic tree as second column (see ORFmine/examples/database/orfdate_inputs/ for an example). It, therefore, involves the fasta files of the complete proteomes (amino acid sequences) of the focal and its neighbors to be stored in the corresponding directories. the fasta files containing all the amino acid sequences of the focal and its neighboring species. All the inputs must be stored in the /database/ directory, though a subdirectory can be created for more clarity (e.g. /database/orfdate_inputs/). The following command line will estimate the ages of 42 yeast CDSs (subsample of yeast CDSs that can be found in the file ORFmine/examples/database/orfdate_inputs/sample_42_Scer_CDS.pfasta) based on the phylogenetic tree of the Saccharomyces sensu stricto (i.e. S. cerevisiae, S. paradoxus, S. mikatae, S. kudrievezii, S. arboricola and S. bayanus )(the corresponding tree can be found in ORFmine/examples/database/orfdate_inputs/Saccharomycew_species.nwk). Please note that the last node of the tree will be used as the upper limit for the age estimation. Consequently, all sequences with a match in the farest species, with respect to the focal, are associated with the same upper bounded estimated age regardless of whether they may have other matches in more distant species outside the input tree (see Papadopoulos et al, [3] for more details). orfdate -focal Scer -tree /database/orfdate_inputs/Saccharomyces_species.nwk -names /database/orfdate_inputs/names.csv with the -focal option corresponding to the name of the focal species as indicated in the tree. Please note that additional arguments including BLAST parameters can be provided. See here for more details. An example of the names.csv file is available in the ORFmine/examples/database/orfdate_inputs/ directory as well as the 5 fasta files containing all the sequences of the 5 neighboring species of the focal. ORFdate generates two outputs in csv format located in the /workdir/orfdate/ directory. Examples of these outputs can be found in the ORFmine/exmaples/workdir/orfdate/ folder. sample_42_Scer_CDS_hits.csv which reports the number of significant matches for all sequences of the focal species (rows) across the neighbors species of the tree (columns) sample_42_Scer_CDS_dated.csv which reports for each sequence (col 1), the farest neighbor species for which a significant math has been found (col2), and the time of divergence between this neighbor and the focal species in Mya (col3) ORFdate generates also intermediate files (blast databases and blast outputs) which are stored in the /workdir/orfdate/blastdb/ and /workdir/orfdate/blastout/ directories. Examples of such outputs can be found in the ORFmine/examples/workdir/orfdate/ directory. References # Bitard-Feildel, T. & Callebaut, I. HCAtk and pyHCA: A Toolkit and Python API for the Hydrophobic Cluster Analysis of Protein Sequences. bioRxiv 249995 (2018). M\u00e9sz\u00e1ros B, Erd\u0151s G, Doszt\u00e1nyi Z (2018) IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46:W329\u2013W3372. Papadopoulos, C., Arbes, H., Chevrollier, N., Blanchet, S., Cornu, D., Roginski, P., Rabier, C., Atia, S., Lespinet, O., Namy, O., Lopes, A. (submitted).","title":"Quick start"},{"location":"orfmine_quickstart.html#quick-start","text":"Here we first explain how to prepare the folders necessary for ORFmine and launch the container . In addition, are presented several examples of the use of the different programs of ORFmine: annotation and extraction of all the ORFs (coding and noncoding) of a genome with ORFtrack and its companion program ORFget prediction of the fold potential of all noncoding ORFs of a genome with ORFold characterization of the translation activity of all intergenic ORFs of a genome with ORFribo estimation of the ages of all the CDSs of a genome with ORFdate All the inputs used in these examples are available in the ORFmine/examples/ folder that can be dowloaded here .","title":"Quick start"},{"location":"orfmine_quickstart.html#prepare-your-directories","text":"First, you need to prepare your directories (that will depend on the usage) with the appropriate data. These directories will then be bound to your container when launching the container, so that your data will be accessible to the ORFmine programs (see here for launching the container). Your future container will have the following architecture: / \u251c\u2500\u2500 database \u251c\u2500\u2500 fastq \u2514\u2500\u2500 workdir \u251c\u2500\u2500 orfdate \u251c\u2500\u2500 orfold \u2514\u2500\u2500 orfribo","title":"Prepare your directories"},{"location":"orfmine_quickstart.html#database-directory-any-usage","text":"Several files must be provided in order to run the different ORFmine programs. They need to be placed in the same directory whatever the programs to be used. This directory will then be bound to the /database directory of your future container. For ORFtrack: A fasta file with the reference genome sequence (e.g. genome.fa) A gff file with the reference genome annotation (e.g. genome.gff3) For ORFribo: A fasta file with the reference genome sequence (e.g. genome.fa) A gff file with the reference genome annotation (e.g. genome.gff3) A fasta file with the sequences you do not want to treat and that you want to remove from the mapping, usually rRNA sequences (e.g. outRNA.fa) For ORFold: A fasta file with the amino acid sequences to treat A gff file (optional) if you want to map the HCA, Tango or IUPred scores along the chromosome and to see them with a genome browser like IGV. For ORFdate: Fasta files of the complete proteomes (amino acid sequences) of the focal species and its neighbors The corresponding tree (nwk format) Table (2 columns) with the paths to the fasta files of proteomes and the names of the corresponding species More details are given in the corresponding sections. All these files whatever the programs you will run must be in the same local directory (though subdirectories can be created for more clarity but they must be in the same global directory) that will constitute the /database directory of the future container. You are free to choose the name and the path of the folder in your local machine.","title":"database directory (any usage)"},{"location":"orfmine_quickstart.html#working-directory-any-usage","text":"When creating the container, please be aware that you will choose a directory that will be your working directory and where some of the outputs will be written. Particular case of ORFribo: The working directory must contain the configuration file called config.yaml , completed by the user (see here for more details on how to complete the config.yaml ). This directory will then be bound on the /workdir directory of your future container. You are free to choose the name and the path of the folder in your local machine.","title":"working directory (any usage)"},{"location":"orfmine_quickstart.html#fastq-directory-orfribo","text":"If you want to use ORFribo, you must place the Ribosome Profiling data (i.e. the fastq(.gz) files) in a specific folder without anything else inside it . You can have this folder wherever you want on your computer and name it as you like. This directory will then be bound to the /fastq directory of your future container.","title":"fastq directory (ORFribo)"},{"location":"orfmine_quickstart.html#launch-the-container","text":"To launch the container and get an interactive shell inside it, you can use either the \"singularity \" or the \"docker\" commands. Every folder that you have prepared before must be bound to their corresponding folders inside the container through the -v or -B options (see the command lines below). In the following command lines, every italics part has to be adapted from your computer's organization (names and paths) and the other parts are part of the container structure and must remain as they are! Using singularity singularity shell --pwd /workdir/ \\ -B PATH_TO_YOUR_WORKING_DIR :/workdir/ \\ -B PATH_TO_YOUR_DATA_DIR :/database/ \\ -B PATH_TO_YOUR_FASTQ_DIR :/fastq/ \\ PATH_TO_YOUR_ORFMINE_IMAGE .sif Using docker The same logic applies with the docker command except that absolute paths must be given: docker run --rm -it \\ -v ABSOLUTE_PATH_TO_YOUR_WORKING_DIR :/workdir/ \\ -v ABSOLUTE_PATH_TO_YOUR_DATA_DIR :/database/ \\ -v ABSOLUTE_PATH_TO_YOUR_FASTQ_DIR :/fastq/ \\ annelopes94/orfmine:v0.8.7 Please note that if you do not want to use ORFribo, you do not need to link the fastq folder to the container and can remove the binding part of the command line: PATH_TO_YOUR_FASTQ_DIR :/fastq/ . See here for more details on how to bind your local folders to those of the container.","title":"Launch the container"},{"location":"orfmine_quickstart.html#binding-tango-andor-iupred","text":"If you want to use Tango and/or IUPred with ORFfold, you will need to have those softwares installed on your local computer (choose the Unix compatible source code for Tango). Once installed, please place the parent directory content of those softwares inside a directory of your choice. Below is a description of the workflow we followed: # let's consider Tango is installed in ~\\tango and IUPred in ~/iupred2a # create a directory that will contain Tango and IUPred source codes content mkdir ~/softwares # place Tango and IUPred source codes content in softwares cp ~/tango ~/softwares cp -r ~/iupred2a/* ~/softwares To use Tango and/or IUPred on the container, you must launch your container by binding the directory created above to a specific directory on the container For singularity: singularity shell --pwd /workdir/ \\ -B PATH_TO_YOUR_WORKING_DIR :/workdir/ \\ -B PATH_TO_YOUR_DATA_DIR :/database/ \\ -B PATH_TO_YOUR_FASTQ_DIR :/fastq/ \\ -B PATH_TO_YOUR_DIR_CONTAINING_TANGO_OR_IUPRED :/ORFmine/orfold_v1/orfold/softwares/ \\ PATH_TO_YOUR_ORFMINE_IMAGE .sif For docker: docker run --rm -it \\ -v ABSOLUTE_PATH_TO_YOUR_WORKING_DIR :/workdir/ \\ -v ABSOLUTE_PATH_TO_YOUR_DATA_DIR :/database/ \\ -v ABSOLUTE_PATH_TO_YOUR_FASTQ_DIR :/fastq/ \\ -v ABSOLUTE_PATH_TO_YOUR_DIR_CONTAINING_TANGO_OR_IUPRED :/ORFmine/orfold_v1/orfold/softwares/ \\ annelopes94/orfmine:v0.8.7 Note When launching the container with docker, the annelopes94/orfmine:v0.8.7 part can be changed if you want to launch a specific version of ORFmine. For example : annelopes94/orfmine:v0.8.6 . If you do not know which versions you have on your computer, you can print them by typing docker image ls WARNING: please keep in mind that, once launched, you work inside the container. Filenames in the command lines must, therefore, be indicated either alone (i.e. without any path) or prefixed with the path of the folder as it is inside the container (i.e. path relative to the container not to your local machine - e.g. /database, /fastq, /workdir). For example, when running ORFold, the fasta filenames must be indicated in the command line as follows: orfold -faa sequences.fasta OR orfold -faa /database/sequences.fasta Again, do not indicate the path of the sequences.fasta file according to your local machine architecture - the container only refers to its relative paths. If you want autocompletion when writing the filenames, you need to precise the path of the folder containing the corresponding files (relative path according to the container). You can verify the content of your directories as follows: ls /workdir/ This should display all the files and folders of the working directory. Or : ls /database/ This should display all the files and folders of the data folder containing all the data files (fasta, gff, ...).","title":"Binding Tango and/or IUPred"},{"location":"orfmine_quickstart.html#examples-of-orfmine-usage","text":"To guide the user, all command line examples will rely on the examples directory that can be found here . If you want to follow the guidelines, please follow the procedure below: # place examples.zip on a directory and unzip it mkdir ~/orfmine_tutorial mv ~/Downloads/examples.zip ~/orfmine_tutorial cd ~/orfmine_tutorial/ unzip examples.zip cd examples/ # launch the container (docker usage case). docker run --rm -it -v $(pwd)/workdir:/workdir/ -v $(pwd)/database:/database/ -v $(pwd)/fastq:/fastq/ annelopes94/orfmine:v0.8.7 # or with singularity (considering your .sif image is there: ~/orfmine/orfmine_v0.8.7.sif) singularity shell --pwd /workdir/ -B workdir:/workdir/ -B database</i>:/database/ -B fastq</i>:/fastq/ ~/orfmine/orfmine_v0.8.7.sif After following this procedure, you could juste copy/paste all of the commands below to test them directly.","title":"Examples of ORFmine usage"},{"location":"orfmine_quickstart.html#annotation-and-extraction-of-orfs-with-orftrack","text":"","title":"Annotation and extraction of ORFs with ORFtrack"},{"location":"orfmine_quickstart.html#annotation-of-orfs","text":"ORFtrack takes as input (i) a fasta file containing the nucleotide sequences of all chromosomes or contigs, and (ii) the corresponding annotations in a gff file (see the GFF3 documentation for more details on the GFF3 format). Please notice that we strongly recommend using GFF3 formats. The following command runs ORFtrack on the complete genome of Saccharomyces cerevisiae ( Scer ) available in the ORFmine/examples folder: orftrack -fna /database/Scer.fna -gff /database/Scer.gff ORFtrack generates a novel gff file mapping_orf_Scer.gff that contains the annotations of all the identified ORFs (see here for more details on the annotation process). The output file is located in /database/. Indeed, all the ORFtrack and ORFget outputs are stored in /database/ since they might constitute the inputs of the other ORFmine programs. A copy of the output can be found in the ORFmine/examples/database/ folder). Please note that ORFtrack also generates a summary.log file that lists all the ORF categories it has identified.","title":"Annotation of ORFs"},{"location":"orfmine_quickstart.html#extraction-of-the-sequences-of-noncoding-orfs-in-a-fasta-format","text":"The amino acid sequences of all annotated ORFs or specific subsets of ORFs (i.e. only noncoding intergenic ORFs for example) can be extracted and written in a fasta file with ORFget, a tool provided with ORFtrack. The following instruction writes the amino acid sequences of all yeast noncoding ORFs (including noncoding intergenic ORFs and those that overlap with a genomic feature). ORFget therefore needs the genome sequence (nucleotides) from which the ORF sequences will be extracted and translated into amino acids and the ORFtrack output gff file with the annotations and coordinates of all the identified ORFs. The -features_include option indicates the features to be matched in the names of the ORFs that we want to extract. In this case, we are interested in all noncoding ORFs (i.e. all ORFs containing the flag \"nc\" - see here for more details on the annotation rules of the ORFs), so we indicate it to ORFget through the \"-features_include nc\" option (see here for more examples). orfget -fna /database/Scer.fna -gff /database/mapping_orf_Scer.gff -features_include nc ORFget produces a fasta file (mapping_orf_Scer_nc.pfasta) containing the amino acid sequences of all noncoding ORFs annotated by ORFtrack (see here for more examples on the use of ORFget).The output fasta is stored in /database/ directory of the container and renamed based on the gff file rootname and the include features. The user can also extract the nucleotide sequences through the \"-type\" option (-type nucl) or both amino acid and nucleotide sequences (-type both).","title":"Extraction of the sequences of noncoding ORFs in a fasta format"},{"location":"orfmine_quickstart.html#extraction-of-the-sequences-of-the-cdss-of-yeast-in-a-fasta-format","text":"In addition, ORFget enables the reconstruction of all coding sequences (CDSs) of the input genome (in this examlpe, Scer) according to their annotation in the original gff file. When different isoforms are described, it will generate all of them according to the gff file. It, therefore, needs as input the original gff file (not the one created by ORFtrack which only contains STOP-to-STOP ORFs) and the genome sequence in FASTA format. orfget -fna /database/Scer.fna -gff /database/Scer.gff -features_include CDS The output is generated in the /database/ directory of the container. An example of this output is available in the ORFmine/examples/database/ directory.","title":"Extraction of the sequences of the CDSs of yeast in a fasta format"},{"location":"orfmine_quickstart.html#characterization-of-the-fold-potential-and-disorder-and-aggregation-propensities-of-the-noncoding-orfs-with-orfold","text":"","title":"Characterization of the fold potential and disorder and aggregation propensities of the noncoding ORFs with ORFold"},{"location":"orfmine_quickstart.html#running-orfold","text":"ORFold only needs a fasta file containing the amino acid sequences to characterize. In the following example, ORFold will estimate the foldability and the disorder and aggregation propensities of all the amino acid sequences potentially encoded in the noncoding ORFs of yeast. orfold -faa /database/mapping_orf_Scer_nc.pfasta -options H with -options H to indicate that we want to estimate the foldability (H for HCA). ORFold generates one table that is stored in the /workdir/orfold directory of the container (a copy of the output can be found in ORFmine/examples/workdir/orfold directory). The table contains for each input sequence, the fold potential as calculated by HCA [1] (see here for more details on the calculation of this score). In addition, a gff file containing the annotation of the input sequences can be provided as well. In this case, ORFold writes the fold potential and disorder and aggregation propensities in the 9th column of three gff files respectively. The latter can be subsequently uploaded on a genome viewer like IGV for a visual inspection of the distribution of these properties along the genome. The following instruction enables the user to probe the fold potential and disorder and aggregation propensities of all the yeast noncoding ORFs annotated by ORFtrack and takes as inputs the corresponding fasta file and the gff file generated by ORFtrack (mapping_orf_Scer.gff located in /database/). orfold -faa /database/mapping_orf_Scer_nc.pfasta -options H -gff /database/mapping_orf_Scer.gff In addition to the score table, ORFold has generated a new gff file containing for each ORF its fold potential. The output gff file is stored in the /workdir/orfold directory of the container and can be subsequently uploaded on a genome viewer.","title":"Running ORFold"},{"location":"orfmine_quickstart.html#visualization-of-the-distribution-of-the-fold-potential-with-orfplot","text":"ORFplot enables the visualization of the distribution of the fold potential of the amino acid sequences potentially encoded in noncoding ORFs along with the one of a reference dataset of globular proteins taken from M\u00e9sz\u00e1ros et al. [2]. It takes as input the table generatd by ORFold that must be located in the /workdir/orfold/ directory of the container. orfplot -tab /workdir/orfold/mapping_orf_Scer_nc.tab -names \"Yeast noncoding ORFs\" The output graphic is generated in PNG and PDF formats and stored in the /workdir/orfold directory of the container (see here for other examples of use of ORFplot). Each distribution is compared with the one of the globular protein dataset with a Kolmogorov Smirnov test. Asterisks on the plot denote level of significance: * < 0.05, * * < 0.01, *** < 0.001.","title":"Visualization of the distribution of the fold potential with ORFplot"},{"location":"orfmine_quickstart.html#characterization-of-the-translation-activity-of-all-intergenic-orfs-of-yeast","text":"ORFribo, based on ribosome-profiling data, probes the translation activity of all the ORFs of interest of a genome (be they coding or noncoding) that are annotated in a gff file. We strongly recommend using ORFtrack to generate the gff file since ORFtrack and ORFribo were jointly developed so that the output of ORFtrack fits the prerequisites of ORFribo. In this example, we investigate the translation of all intergenic ORFs of yeast annotated as \"nc_intergenic\" by ORFtrack in its output mapping_orf_Scer.gff. An example of this file that has been generated by ORFtrack and that will be used as input by ORFribo is available in the ORFmine/examples/database/ folder. Here is presented a simple example that enables one to run ORFribo from inputs and a pre-configurated config.yaml file which are all available in the ORFmine/examples/ folder. However, before running ORFribo on this example dataset, we recommend the user read in details the phylosophy and main steps of ORFribo.","title":"Characterization of the translation activity of all intergenic ORFs of yeast"},{"location":"orfmine_quickstart.html#input-files","text":"ORFribo relies on the fastq file(s) (Ribo-Seq dataset(s)) that must be stored in the /fastq/ folder of the container - an example of such file is available in the ORFmine/examples/fastq folder /fastq/XYZ.fastq and 4 additional files that must be stored in the /database/ folder of the container. Examples of such files are available in the ORFmine/examples/database/ folder. Scer.fna: fasta file containing the nucleotide sequences of the chromosomes of the yeast genome Scer.gff: the original annotation of yeast in a gff file mapping_orf_Scer.gff: the gff file containing all the ORFs detected by ORFtrack and including the nc_intergenic ORFs for which we want to estimate the translation activity. It therefore involves that you have previously generated this file as presented here Scer_rRNA.fa: A fasta file with the sequences that we want to remove from the mapping step, here rRNA sequences","title":"Input files"},{"location":"orfmine_quickstart.html#preparing-the-configyaml-file","text":"ORFribo is very easy to handle and only needs a configuration file to be edited before running it. The latter named config.yaml contains the parameters that can be adjusted by the user. The full description of this file is available here . For this example, a pre-filled configuration file is present is the ORFmine/examples/workdir/ directory. Please place the config.yaml file in the /workdir/ directory of your container and edit it if needed following the instructions presented here :","title":"Preparing the config.yaml file"},{"location":"orfmine_quickstart.html#running-orfribo","text":"The only parameters to adjust in the command line are: The number of virtual CPUs/threads to reserve for the analysis The approximate amount of memory to reserve for the analysis (in GB) ORFribo is launched like this: orfribo CPU MEMORY For example, for an analysis launched with the use of 6 CPUs and around 10GB of memory, it would be: orfribo 6 10 Be careful to have enough memory on your computer/cluster for you analysis as a lack of RAM would lead the pipeline to crash without giving any error message. So if the program stops without any obvious reason this might be the reason why, and one should restart the pipeline with more resources.","title":"Running ORFribo"},{"location":"orfmine_quickstart.html#main-outputs","text":"ORFribo generates many intermediate files that can be useful for further analysis. Their description is available here . The main output is the table named genome_mean70_median70_reads_concatenated.tab that summarizes the results for each ORF of interest (e.g. nb and fractions of F0, F1 and F2 reads). An example of this output table can be found in the /workdir/orfribo/RESULTS/Bam2Reads_genome_output/SRR1520313_17031088/ directory. A full description of the summary table can be found here .","title":"Main outputs"},{"location":"orfmine_quickstart.html#running-orfdate","text":"ORFdate estimates the evolutionary ages of a set of ORFs (coding but also noncoding) based on phylostratigraphy. It takes as inputs: a distance phylogenetic tree in newick format, containing the species of interest (focal species) and its neighbors (see ORFmine/examples/database/orfdate_inputs/ for an example). All branches must be associated with their relative distance on which the age estimation will be based. a two columns csv file (i.e. columns separated by commas) with the path to the sequence fasta files of each species as first column, and the associated species names as indicated in the phylogenetic tree as second column (see ORFmine/examples/database/orfdate_inputs/ for an example). It, therefore, involves the fasta files of the complete proteomes (amino acid sequences) of the focal and its neighbors to be stored in the corresponding directories. the fasta files containing all the amino acid sequences of the focal and its neighboring species. All the inputs must be stored in the /database/ directory, though a subdirectory can be created for more clarity (e.g. /database/orfdate_inputs/). The following command line will estimate the ages of 42 yeast CDSs (subsample of yeast CDSs that can be found in the file ORFmine/examples/database/orfdate_inputs/sample_42_Scer_CDS.pfasta) based on the phylogenetic tree of the Saccharomyces sensu stricto (i.e. S. cerevisiae, S. paradoxus, S. mikatae, S. kudrievezii, S. arboricola and S. bayanus )(the corresponding tree can be found in ORFmine/examples/database/orfdate_inputs/Saccharomycew_species.nwk). Please note that the last node of the tree will be used as the upper limit for the age estimation. Consequently, all sequences with a match in the farest species, with respect to the focal, are associated with the same upper bounded estimated age regardless of whether they may have other matches in more distant species outside the input tree (see Papadopoulos et al, [3] for more details). orfdate -focal Scer -tree /database/orfdate_inputs/Saccharomyces_species.nwk -names /database/orfdate_inputs/names.csv with the -focal option corresponding to the name of the focal species as indicated in the tree. Please note that additional arguments including BLAST parameters can be provided. See here for more details. An example of the names.csv file is available in the ORFmine/examples/database/orfdate_inputs/ directory as well as the 5 fasta files containing all the sequences of the 5 neighboring species of the focal. ORFdate generates two outputs in csv format located in the /workdir/orfdate/ directory. Examples of these outputs can be found in the ORFmine/exmaples/workdir/orfdate/ folder. sample_42_Scer_CDS_hits.csv which reports the number of significant matches for all sequences of the focal species (rows) across the neighbors species of the tree (columns) sample_42_Scer_CDS_dated.csv which reports for each sequence (col 1), the farest neighbor species for which a significant math has been found (col2), and the time of divergence between this neighbor and the focal species in Mya (col3) ORFdate generates also intermediate files (blast databases and blast outputs) which are stored in the /workdir/orfdate/blastdb/ and /workdir/orfdate/blastout/ directories. Examples of such outputs can be found in the ORFmine/examples/workdir/orfdate/ directory.","title":"Running ORFdate"},{"location":"orfmine_quickstart.html#references","text":"Bitard-Feildel, T. & Callebaut, I. HCAtk and pyHCA: A Toolkit and Python API for the Hydrophobic Cluster Analysis of Protein Sequences. bioRxiv 249995 (2018). M\u00e9sz\u00e1ros B, Erd\u0151s G, Doszt\u00e1nyi Z (2018) IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic acids research 46:W329\u2013W3372. Papadopoulos, C., Arbes, H., Chevrollier, N., Blanchet, S., Cornu, D., Roginski, P., Rabier, C., Atia, S., Lespinet, O., Namy, O., Lopes, A. (submitted).","title":"References"},{"location":"orfribo_advanced.html","text":"Run on multiple datasets # ORFribo can handle multiple Ribosome Profiling datasets provided they correspond to the same genome. To do so, the user only need to store all the corresponding fastq files in the /fastq/ directory. ORFribo will treat all the datasets independently and will generate as many output tables as there are input fastq files. The generated main output tables are then merged together into a single table written in the /workdir/orfribo/RESULTS/Bam2Reads_genome_output/ and is named \"all_samples_genome_meanXX_medianYY_reads_concatenated.tab\". We recall that the config.yaml file must be completed and stored in the /workdir/ directory of the container. One should note that the same parameters will be applied to all datasets. If you want to add some files to your experiment when ORFribo is already done for some fastqs, just put the new fastqs in the /fastq/ folder and launch the analysis again. ORFribo is smart enough (!) to only execute the needed steps for your analysis. The same logic applies if you change some parameters in the configuration file config.yaml or change the input files. If a file is modified in any way by the user or if a newer one takes its place, the downstream steps of the pipeline based on the modified file will be executed but no more (based on files' timestamp). For example, you can also wait for the analysis to be finished, then change the selection thresholds in your configuration file and start ORFribo again. The new outputs will be created only after the necessary steps will be made, without trimming the adapters and aligning the reads on the genome's sequence once again. Probing the translation activity of CDSs # ORFmine is ORF-centered (i.e. ORFs defined from STOP-to-STOP), thus the ORFtrack output, that is used by most of ORFmine tools including ORFribo for the read mapping, only contains ORFs as defined by ORFtrack. Consequently, the ORFtrack output contains ORFs that include a CDS or CDS exons but not the real intronless CDSs (ATG-STOP) as defined in the original annotation gff file. If the user wants to probe the translation of CDSs, he/she therefore needs to extract the information that is stored in the outputs of step 2 (the kmer quality control performed on CDSs). To do so, the user has to identify for the studied dataset (e.g. dataset_XYZ), the retained kmers which are stored in this file: /workdir/orfribo/RESULTS/selected_tables/threshold_meanXX_medianXX/dataset_XYZ.txt. This file lists all the retained kmers. The CDS read counts are written in the corresponding tables stored in /workdir/orfribo/RESULTS/ORFribo/Bam2Reads_exome_output/dataset_XYZ_kmer_i/ with kmer_i standing for the retained kmers. The user thus needs to pool the corresponding count tables into a single table of same format as the final output through our script as described below. If for example, for the dataset_XYZ for which the retained kmers were the 27mers, 28mers and 31mers, the user can pool all the count tables based on the mapping of the 27-, 28- and 31mers as follows: python3 /ORFmine/orfribo/RiboDoc_BAM2Reads/tools/Bam2Reads_function/concatenate.py -tables /workdir/orfribo/RESULTS/ORFribo/Bam2Reads_exome_output/dataset_XYZ_27/exome.25-35_reads.tab /workdir/orfribo/RESULTS/ORFribo/Bam2Reads_exome_output/dataset_XYZ_28/exome.25-35_reads.tab /workdir/orfribo/RESULTS/ORFribo/Bam2Reads_exome_output/dataset_XYZ_31/exome.25-35_reads.tab -outpath /workdir/orfribo/ -outname CDS_translation_XYZ.tab The resulting table contains for each CDS, the numbers and frequencies of reads in its F0, F1 anf F2 frames.","title":"Advanced run ORFribo"},{"location":"orfribo_advanced.html#run-on-multiple-datasets","text":"ORFribo can handle multiple Ribosome Profiling datasets provided they correspond to the same genome. To do so, the user only need to store all the corresponding fastq files in the /fastq/ directory. ORFribo will treat all the datasets independently and will generate as many output tables as there are input fastq files. The generated main output tables are then merged together into a single table written in the /workdir/orfribo/RESULTS/Bam2Reads_genome_output/ and is named \"all_samples_genome_meanXX_medianYY_reads_concatenated.tab\". We recall that the config.yaml file must be completed and stored in the /workdir/ directory of the container. One should note that the same parameters will be applied to all datasets. If you want to add some files to your experiment when ORFribo is already done for some fastqs, just put the new fastqs in the /fastq/ folder and launch the analysis again. ORFribo is smart enough (!) to only execute the needed steps for your analysis. The same logic applies if you change some parameters in the configuration file config.yaml or change the input files. If a file is modified in any way by the user or if a newer one takes its place, the downstream steps of the pipeline based on the modified file will be executed but no more (based on files' timestamp). For example, you can also wait for the analysis to be finished, then change the selection thresholds in your configuration file and start ORFribo again. The new outputs will be created only after the necessary steps will be made, without trimming the adapters and aligning the reads on the genome's sequence once again.","title":"Run on multiple datasets"},{"location":"orfribo_advanced.html#probing-the-translation-activity-of-cdss","text":"ORFmine is ORF-centered (i.e. ORFs defined from STOP-to-STOP), thus the ORFtrack output, that is used by most of ORFmine tools including ORFribo for the read mapping, only contains ORFs as defined by ORFtrack. Consequently, the ORFtrack output contains ORFs that include a CDS or CDS exons but not the real intronless CDSs (ATG-STOP) as defined in the original annotation gff file. If the user wants to probe the translation of CDSs, he/she therefore needs to extract the information that is stored in the outputs of step 2 (the kmer quality control performed on CDSs). To do so, the user has to identify for the studied dataset (e.g. dataset_XYZ), the retained kmers which are stored in this file: /workdir/orfribo/RESULTS/selected_tables/threshold_meanXX_medianXX/dataset_XYZ.txt. This file lists all the retained kmers. The CDS read counts are written in the corresponding tables stored in /workdir/orfribo/RESULTS/ORFribo/Bam2Reads_exome_output/dataset_XYZ_kmer_i/ with kmer_i standing for the retained kmers. The user thus needs to pool the corresponding count tables into a single table of same format as the final output through our script as described below. If for example, for the dataset_XYZ for which the retained kmers were the 27mers, 28mers and 31mers, the user can pool all the count tables based on the mapping of the 27-, 28- and 31mers as follows: python3 /ORFmine/orfribo/RiboDoc_BAM2Reads/tools/Bam2Reads_function/concatenate.py -tables /workdir/orfribo/RESULTS/ORFribo/Bam2Reads_exome_output/dataset_XYZ_27/exome.25-35_reads.tab /workdir/orfribo/RESULTS/ORFribo/Bam2Reads_exome_output/dataset_XYZ_28/exome.25-35_reads.tab /workdir/orfribo/RESULTS/ORFribo/Bam2Reads_exome_output/dataset_XYZ_31/exome.25-35_reads.tab -outpath /workdir/orfribo/ -outname CDS_translation_XYZ.tab The resulting table contains for each CDS, the numbers and frequencies of reads in its F0, F1 anf F2 frames.","title":"Probing the translation activity of CDSs"},{"location":"orfribo_configuration.html","text":"Before launching ORFribo: prepare the config.yaml # ORFribo is very easy to handle and only needs a configuration file to be edited before running it. The latter named config.yaml contains the parameters that can be adjusted by the user. Here we describe how to fill this file (a pre-filled configuration file is present in the ORFmine/examples/workdir/ directory and corresponds to the example dataset provided in ORFmine/examples/). Please note that every file's name must be written without path and they must be placed in your local folder linked to the /database/ directory of the container. The fastq files must be stored in your local fastq/ directory that has been linked to the /fastq/ directory of the container when having launched the container. Please note that we strongly recommend reading the How it works? page before completing the configuration file. Please place the config.yaml file in the /workdir/ directory of your container and edit it as follows (WARNING all parameters must be written between quotes as in the example): Project name # project_name : \"intergenic_ORF_translation\" (the name of your project without spaces or special characters) Input names # You must enter the full name ( with extensions and without the path ) of the genome sequence and annotation files of the genome to be treated. These two files must be stored in the /database/ folder of the container. Examples of such files can be found in the ORFmine/examples/database/ folder. fasta : \"Scer.fna\" (i.e. reference_genome_sequences.fa: fasta file containing the nucleotide sequence of the complete genome) gff : \"Scer.gff\" (i.e. reference_genome_annotations.gff: annotation file) gff_intergenic : \"mapping_orf_Scer.gff\" (i.e. ORFtrack_output.gff: name of the ORFtrack output gff file containing the ORF coordinates for which you want to study the translation activity) fasta_outRNA : \"Scer_rRNA.fa\" (i.e. NA_sequences_to_remove.fa: sequences for which you do not want to map Ribo-Seq reads - usually rRNAs etc) Pipeline option selection # During the ORFribo process, data is trimmed and selected depending on the read lengths. already_trimmed : \"no\" (If your data contains reads already trimmed of their adapter, you can set this option to \u201cyes\u201d. Else, set it to \"no\") adapt_sequence : \"AGATCGGAAGAGCACACGTCTGAACTCCAGTCA\" (If they are not trimmed, you should specify the sequence of the adapter in quotes on the line here like \"AGATCGGAAGAGCACACGTCTGAACTCCAGTCA\". If you do not put anything between the quotes, and the option \"already_trimmed\" has been set to \"no\", ORFribo will try to find the adapter itself but this can sometimes lead to a wrong adapter sequence) Kmers (or read sizes) to analyze # You have to define the range of read sizes (kmers) that will be tested. By default, ORFribo will test the quality of kmers/reads from 25 to 35 bases long and will retain those of good quality (i.e. those which mostly map to the coding phase (P0) of CDSs - \"mostly\" corresponding to a median value of 70% but it can be modified by the user). readsLength_min : \"25\" (minimum read size (default 25)) readsLength_max : \"35\" (maximum read size (default 35)) Names of coding features for the detection of kmers of good quality (Step 2) # You might also need to specify the names, as indicated in the original gff file (not the one generated by ORFtrack), of the \"CDS\" feature and \"gene\" attribute so that ORFribo is able to identify the features/attributes that correspond to the CDSs and genes. That said, we strongly recommend using the \"CDS\" and \"gene\" keywords for the CDSs and genes respectively as they are used by ORFtrack in its gff output. Using different keywords for these two features might generate conflicts with the detection of good quality kmers ( Step2 ) and the read mapping step ( Step3 ) which is realized on the ORFtrack output or equivalent. To avoid such conflicts, we recommend modifying in the original gff file the names of the attributes/features used for the genes and CDSs to \"gene\" and \"CDS\" respectively. gff_cds_feature : \"CDS\" (Feature name (column 3) corresponding to CDSs in the original annotation gff file that will be used for the second step \" Detection of kmers of good quality \". Usually, CDSs are referred to as \"CDS\" in the gff files, so \"CDS\" is the default value. That said, one should note that CDSs may be referred to as \"ORF\" in some gff files, in this case, this option should be set to \"ORF\", though we strongly recommend editing the initial gff file and replace the feature name \"ORF\" by \"CDS\".) gff_name_attribut : \"Name\" (Name of the gene name attribute in the initial gff file (column 9). Default is \"Name\" but like for CDSs, please control the name referring to the gene name attribute and modify this option accordingly (some gff files refer to gene name attributes as \"gene_name\"), though we strongly recommend editing the initial gff file and replace the feature name \"gene_name\" by \"gene\".) Names of features or ORF categories to be analyzed (noncoding but also coding) # final_counts : \"nc_intergenic\" (List of ORF categories for which you want to investigate the translation activity ( Step3 ). The ORF categories listed here must correspond to those provided by ORFtrack in the 3rd column of the output gff file (the ORF categories identified in your input genome can also be found in the summary.log of ORFtrack). Examples of these two files can be found in the ORFmine/examples/database/ directory as maping_orf_Scer.gff or summary.log files. By default, ORFribo will probe the translation activity of all intergenic ORFs which are referred to as \"nc_intergenic\" (see here for more details on the ORF categories and annotation process). If you want to also probe that of noncoding ORFs lying in the alternative frames of CDSs on the same strand for example, you must add the \"nc_ovp_same-CDS\" flag separated by a space as follows: \"nc_intergenic nc_ovp_same-CDS\".) Statistical settings # orfstats_mean_threshold : \"70\" (Minimum mean of in-frame reads in coding regions to select specific read sizes/kmers (default is 70)) orfstats_median_threshold : \"70\" (Minimum median of in-frame reads in coding regions to select specific read sizes/kmers (default is 70))","title":"ORFribo configuration"},{"location":"orfribo_configuration.html#before-launching-orfribo-prepare-the-configyaml","text":"ORFribo is very easy to handle and only needs a configuration file to be edited before running it. The latter named config.yaml contains the parameters that can be adjusted by the user. Here we describe how to fill this file (a pre-filled configuration file is present in the ORFmine/examples/workdir/ directory and corresponds to the example dataset provided in ORFmine/examples/). Please note that every file's name must be written without path and they must be placed in your local folder linked to the /database/ directory of the container. The fastq files must be stored in your local fastq/ directory that has been linked to the /fastq/ directory of the container when having launched the container. Please note that we strongly recommend reading the How it works? page before completing the configuration file. Please place the config.yaml file in the /workdir/ directory of your container and edit it as follows (WARNING all parameters must be written between quotes as in the example):","title":"Before launching ORFribo: prepare the config.yaml"},{"location":"orfribo_configuration.html#project-name","text":"project_name : \"intergenic_ORF_translation\" (the name of your project without spaces or special characters)","title":"Project name"},{"location":"orfribo_configuration.html#input-names","text":"You must enter the full name ( with extensions and without the path ) of the genome sequence and annotation files of the genome to be treated. These two files must be stored in the /database/ folder of the container. Examples of such files can be found in the ORFmine/examples/database/ folder. fasta : \"Scer.fna\" (i.e. reference_genome_sequences.fa: fasta file containing the nucleotide sequence of the complete genome) gff : \"Scer.gff\" (i.e. reference_genome_annotations.gff: annotation file) gff_intergenic : \"mapping_orf_Scer.gff\" (i.e. ORFtrack_output.gff: name of the ORFtrack output gff file containing the ORF coordinates for which you want to study the translation activity) fasta_outRNA : \"Scer_rRNA.fa\" (i.e. NA_sequences_to_remove.fa: sequences for which you do not want to map Ribo-Seq reads - usually rRNAs etc)","title":"Input names"},{"location":"orfribo_configuration.html#pipeline-option-selection","text":"During the ORFribo process, data is trimmed and selected depending on the read lengths. already_trimmed : \"no\" (If your data contains reads already trimmed of their adapter, you can set this option to \u201cyes\u201d. Else, set it to \"no\") adapt_sequence : \"AGATCGGAAGAGCACACGTCTGAACTCCAGTCA\" (If they are not trimmed, you should specify the sequence of the adapter in quotes on the line here like \"AGATCGGAAGAGCACACGTCTGAACTCCAGTCA\". If you do not put anything between the quotes, and the option \"already_trimmed\" has been set to \"no\", ORFribo will try to find the adapter itself but this can sometimes lead to a wrong adapter sequence)","title":"Pipeline option selection"},{"location":"orfribo_configuration.html#kmers-or-read-sizes-to-analyze","text":"You have to define the range of read sizes (kmers) that will be tested. By default, ORFribo will test the quality of kmers/reads from 25 to 35 bases long and will retain those of good quality (i.e. those which mostly map to the coding phase (P0) of CDSs - \"mostly\" corresponding to a median value of 70% but it can be modified by the user). readsLength_min : \"25\" (minimum read size (default 25)) readsLength_max : \"35\" (maximum read size (default 35))","title":"Kmers (or read sizes) to analyze"},{"location":"orfribo_configuration.html#names-of-coding-features-for-the-detection-of-kmers-of-good-quality-step-2","text":"You might also need to specify the names, as indicated in the original gff file (not the one generated by ORFtrack), of the \"CDS\" feature and \"gene\" attribute so that ORFribo is able to identify the features/attributes that correspond to the CDSs and genes. That said, we strongly recommend using the \"CDS\" and \"gene\" keywords for the CDSs and genes respectively as they are used by ORFtrack in its gff output. Using different keywords for these two features might generate conflicts with the detection of good quality kmers ( Step2 ) and the read mapping step ( Step3 ) which is realized on the ORFtrack output or equivalent. To avoid such conflicts, we recommend modifying in the original gff file the names of the attributes/features used for the genes and CDSs to \"gene\" and \"CDS\" respectively. gff_cds_feature : \"CDS\" (Feature name (column 3) corresponding to CDSs in the original annotation gff file that will be used for the second step \" Detection of kmers of good quality \". Usually, CDSs are referred to as \"CDS\" in the gff files, so \"CDS\" is the default value. That said, one should note that CDSs may be referred to as \"ORF\" in some gff files, in this case, this option should be set to \"ORF\", though we strongly recommend editing the initial gff file and replace the feature name \"ORF\" by \"CDS\".) gff_name_attribut : \"Name\" (Name of the gene name attribute in the initial gff file (column 9). Default is \"Name\" but like for CDSs, please control the name referring to the gene name attribute and modify this option accordingly (some gff files refer to gene name attributes as \"gene_name\"), though we strongly recommend editing the initial gff file and replace the feature name \"gene_name\" by \"gene\".)","title":"Names of coding features for the detection of kmers of good quality (Step 2)"},{"location":"orfribo_configuration.html#names-of-features-or-orf-categories-to-be-analyzed-noncoding-but-also-coding","text":"final_counts : \"nc_intergenic\" (List of ORF categories for which you want to investigate the translation activity ( Step3 ). The ORF categories listed here must correspond to those provided by ORFtrack in the 3rd column of the output gff file (the ORF categories identified in your input genome can also be found in the summary.log of ORFtrack). Examples of these two files can be found in the ORFmine/examples/database/ directory as maping_orf_Scer.gff or summary.log files. By default, ORFribo will probe the translation activity of all intergenic ORFs which are referred to as \"nc_intergenic\" (see here for more details on the ORF categories and annotation process). If you want to also probe that of noncoding ORFs lying in the alternative frames of CDSs on the same strand for example, you must add the \"nc_ovp_same-CDS\" flag separated by a space as follows: \"nc_intergenic nc_ovp_same-CDS\".)","title":"Names of features or ORF categories to be analyzed (noncoding but also coding)"},{"location":"orfribo_configuration.html#statistical-settings","text":"orfstats_mean_threshold : \"70\" (Minimum mean of in-frame reads in coding regions to select specific read sizes/kmers (default is 70)) orfstats_median_threshold : \"70\" (Minimum median of in-frame reads in coding regions to select specific read sizes/kmers (default is 70))","title":"Statistical settings"},{"location":"orfribo_inputs.html","text":"ORFribo inputs # ORFribo takes as inputs several files that must be stored either in the /database/ or /fastq/ folders of the container (see here for more details on the preparation of the folders of the container). The following files must be stored in the /database/ directory of the container # a fasta file containing the nucleotide sequences of the chromosomes or contigs of a genome the original annotation of the genome in a gff file (see the GFF3 documentation for more details on the gff3 format). the gff file containing the ORFs to be analyzed. We strongly recommend using the gff file generated by ORFtrack that contains the ORF annotation of the input genome according to ORFtrack definition and parameters (ORF length and overlap ). That said, the user can provide his/her own ORF annotation file. In this case, the ORF category of each annotated ORF (even if there is only one category, it must be named explicitly) must be indicated in the 3rd column of the gff file (see the ORFtrack output as example in ORFmine/examples/database/mapping_orf_Scer.gff) A fasta file with the sequences you do not want to treat and that you want to remove from the mapping, usually rRNA sequences (Ex : Scer_rRNA.fa) The following files must be stored in the fastq directory of the container # Ribosome Profiling data (i.e. the fastq(.gz) files) (the /fastq/ folder must only contain the fastq files without anything else inside) See here for more details on the preparation of the folders. An example of inputs can be found in the ORFmine/examples/ directory.","title":"Inputs"},{"location":"orfribo_inputs.html#orfribo-inputs","text":"ORFribo takes as inputs several files that must be stored either in the /database/ or /fastq/ folders of the container (see here for more details on the preparation of the folders of the container).","title":"ORFribo inputs"},{"location":"orfribo_inputs.html#the-following-files-must-be-stored-in-the-database-directory-of-the-container","text":"a fasta file containing the nucleotide sequences of the chromosomes or contigs of a genome the original annotation of the genome in a gff file (see the GFF3 documentation for more details on the gff3 format). the gff file containing the ORFs to be analyzed. We strongly recommend using the gff file generated by ORFtrack that contains the ORF annotation of the input genome according to ORFtrack definition and parameters (ORF length and overlap ). That said, the user can provide his/her own ORF annotation file. In this case, the ORF category of each annotated ORF (even if there is only one category, it must be named explicitly) must be indicated in the 3rd column of the gff file (see the ORFtrack output as example in ORFmine/examples/database/mapping_orf_Scer.gff) A fasta file with the sequences you do not want to treat and that you want to remove from the mapping, usually rRNA sequences (Ex : Scer_rRNA.fa)","title":"The following files must be stored in the /database/ directory of the container"},{"location":"orfribo_inputs.html#the-following-files-must-be-stored-in-the-fastq-directory-of-the-container","text":"Ribosome Profiling data (i.e. the fastq(.gz) files) (the /fastq/ folder must only contain the fastq files without anything else inside) See here for more details on the preparation of the folders. An example of inputs can be found in the ORFmine/examples/ directory.","title":"The following files must be stored in the fastq directory of the container"},{"location":"orfribo_objectives.html","text":"Aims and general description of ORFribo # ORFribo probes the translation activity of a set of ORFs of a genome based on Ribosome Profilng data (Ribo-Seq). ORFribo is very flexible and handles any type of ORFs once annotated in a gff file (e.g. coding sequences, alternative ORFs (i.e., noncoding ORFs located in the alternative frames of CDSs), intergenic ORFs or a combination of these ORF categories). ORFribo does not predict the translation status of ORFs. In contrast, it calculates the number of reads that map on the genomic coordinates of each ORF of the ORF category of interest and detects their corresponding frame. As a result, for each ORF, it provides the number of reads that map in-frame (i.e. in the reading frame of the ORF named also F0 or P0 frame) and the number of reads that map in its +1 and +2 frames. The user can then classify and/or infer the translation status of each ORF according to these numbers. In other words, ORFribo has no a priori and only aims at calculating these numbers for you, you are then free to take decision based on these numbers and your own criteria.","title":"Objectives"},{"location":"orfribo_objectives.html#aims-and-general-description-of-orfribo","text":"ORFribo probes the translation activity of a set of ORFs of a genome based on Ribosome Profilng data (Ribo-Seq). ORFribo is very flexible and handles any type of ORFs once annotated in a gff file (e.g. coding sequences, alternative ORFs (i.e., noncoding ORFs located in the alternative frames of CDSs), intergenic ORFs or a combination of these ORF categories). ORFribo does not predict the translation status of ORFs. In contrast, it calculates the number of reads that map on the genomic coordinates of each ORF of the ORF category of interest and detects their corresponding frame. As a result, for each ORF, it provides the number of reads that map in-frame (i.e. in the reading frame of the ORF named also F0 or P0 frame) and the number of reads that map in its +1 and +2 frames. The user can then classify and/or infer the translation status of each ORF according to these numbers. In other words, ORFribo has no a priori and only aims at calculating these numbers for you, you are then free to take decision based on these numbers and your own criteria.","title":"Aims and general description of ORFribo"},{"location":"orfribo_outputs.html","text":"Output folder architecture (/workdir/orfribo/): # Here is the folder architecture of the ORFribo output stored in /workdir/orfribo. The following output example is based on the example provided in the /ORFmine/examples/ directory with the fastq SRR1520313_17031088. /workdir/orfribo/ \u251c\u2500\u2500 dag_all.svg \u251c\u2500\u2500 dag_last_run.svg \u251c\u2500\u2500 RESULTS/ \u251c\u2500\u2500 config.yaml \u251c\u2500\u2500 ORFribo_yeast_example.Analysis_Report.txt \u251c\u2500\u2500 adapter_lists/ \u2514\u2500\u2500 SRR1520313_17031088.txt \u251c\u2500\u2500 Bam2Reads_genome_output/ \u251c\u2500\u2500 all_samples_genome.25-35.mean70_median70_reads_concatenated.tab \u2514\u2500\u2500 SRR1520313_17031088 \u251c\u2500\u2500 genome.25-35.mean70_median70_reads_concatenated.tab \u251c\u2500\u2500 length_25 \u251c\u2500\u2500 genome.25-35.mean70_median70_reads.tab \u251c\u2500\u2500 genome.25-35.mean70_median70_periodicity_all.tab \u251c\u2500\u2500 genome.25-35.mean70_median70_periodicity_start.tab \u2514\u2500\u2500 genome.25-35.mean70_median70_periodicity_stop.tab \u251c\u2500\u2500 length_26 \u251c\u2500\u2500 genome.25-35.mean70_median70_reads.tab \u251c ... \u2514\u2500\u2500 length_35 \u2514\u2500\u2500 genome.25-35.mean70_median70_reads.tab \u251c\u2500\u2500 annex_database/ \u251c\u2500\u2500 NamedCDS_Scer.gff \u251c\u2500\u2500 index_bowtie2.1.bt2 \u251c ... \u251c\u2500\u2500 index_hisat2.1.ht2 \u251c ... \u251c\u2500\u2500 outRNA_bowtie2.1.ht2 \u2514 ... \u251c\u2500\u2500 fastqc/ \u251c\u2500\u2500 SRR1520313_17031088_fastqc.html \u2514\u2500\u2500 SRR1520313_17031088_fastqc.zip \u251c\u2500\u2500 selected_tables/ \u2514\u2500\u2500 threshold_mean70_median70 \u2514\u2500\u2500 SRR1520313_17031088.txt \u251c\u2500\u2500 BAM/ \u251c\u2500\u2500 SRR1520313_17031088.25-35.bam \u2514\u2500\u2500 SRR1520313_17031088.25-35.bam.bai \u251c\u2500\u2500 no-outRNA/ \u2514\u2500\u2500 SRR1520313_17031088.25-35.no-outRNA.fastq.gz \u2514\u2500\u2500 ORFribo/ \u251c\u2500\u2500 database/ \u251c\u2500\u2500 exome.nfasta \u251c\u2500\u2500 exome_elongated.nfasta \u251c\u2500\u2500 exome_elongated.nfasta.fai \u251c\u2500\u2500 exome_elongated.gff \u2514\u2500\u2500 exome_elongated_with_gene_features.gff \u251c\u2500\u2500 annex_database/ \u251c\u2500\u2500 exome_elongated.exons_Scer.fna \u251c\u2500\u2500 exome_elongated.exons_Scer.gff.gtf \u251c\u2500\u2500 exome_elongated.exome_index_bowtie2.1.bt2 \u251c\u2500\u2500 ... \u251c\u2500\u2500 exome_elongated.exome_index_hisat2.1.ht2 \u2514\u2500\u2500 ... \u251c\u2500\u2500 BAM_exome/ \u251c\u2500\u2500 exome_elongated.SRR1520313_17031088.25-35.bam \u2514\u2500\u2500 exome_elongated.SRR1520313_17031088.25-35.bam.bai \u251c\u2500\u2500 Bam2Reads_exome_output/ \u251c\u2500\u2500 SRR1520313_17031088_25 \u251c\u2500\u2500 exome.25-35_reads.tab \u251c\u2500\u2500 exome.25-35_periodicity_all.tab \u251c\u2500\u2500 exome.25-35_periodicity_start.tab \u251c\u2500\u2500 exome.25-35_periodicity_stop.tab \u2514\u2500\u2500 exome.25-35_reads.stats \u251c\u2500\u2500 ... \u2514\u2500\u2500 SRR1520313_17031088_35 \u251c\u2500\u2500 exome.25-35_reads.tab \u251c\u2500\u2500 exome.25-35_periodicity_all.tab \u251c\u2500\u2500 exome.25-35_periodicity_start.tab \u251c\u2500\u2500 exome.25-35_periodicity_stop.tab \u2514\u2500\u2500 exome.25-35_reads.stats \u2514\u2500\u2500 riboWaltz/ \u251c\u2500\u2500 psite_offset.csv \u251c\u2500\u2500 best_offset.txt \u2514\u2500\u2500 exome_elongated.SRR1520313_17031088 \u251c\u2500\u2500 21.tiff \u251c\u2500\u2500 22.tiff \u251c\u2500\u2500 ... \u2514\u2500\u2500 35.tiff \u251c\u2500\u2500 benchmarks/ \u251c\u2500\u2500 adapt_trimming \u2514\u2500\u2500 SRR1520313_17031088.benchmark.txt \u2514\u2500\u2500 ... \u251c\u2500\u2500 logs/ \u251c\u2500\u2500 RiboDoc_package_versions.txt \u251c\u2500\u2500 adapt_trimming \u251c\u2500\u2500 SRR1520313_17031088_cutadapt.log \u2514\u2500\u2500 SRR1520313_17031088_trim_value.log \u2514\u2500\u2500 ... \u2514\u2500\u2500 logsTmp/ \u251c\u2500\u2500 SRR1520313_17031088_adapt_trimming.log \u251c\u2500\u2500 SRR1520313_17031088_bowtie2_run_outRNA.log \u251c\u2500\u2500 SRR1520313_17031088_run_mapping_bowtie2.log \u2514\u2500\u2500 SRR1520313_17031088_run_mapping_hisat2.log Main output table # The main output table can be found in the RESULTS/Bam2Reads_genome_output/ folder and is named all_samples_genome.25-35.meanXX_medianYY_reads_concatenated.tab (with X and Y standing for the median and mean thresholds, here 70 and 70 respectively). This table summarizes the results for each ORF (i.e. numbers and fraction of reads in the three frames of the ORF) calculated for all the retained kmers in each input dataset (in this example, there is only one dataset - SRR1520313_17031088.). If ORFribo has been performed on multiple datasets , it also provides for each dataset a folder named according to the dataset that contains a table with the same format as the all_samples_genome.25-35.meanXX_medianYY_reads_concatenated.tab table but calculated only on the retained kmers of the corresponding dataset dataset_XYZ/genome.25-35.mean70_median70_reads_concatenated.tab . The directories of each dataset also contain the intermediate tables calculated for each retained kmer. The latter are stored in the RESULTS/Bam2Reads_genome_output/dataset_xyz/length_i/ directory where i stands for the kmer sizes. When only one dataset has been provided to ORFribo (as in this example), the output table present in the dataset folder is the same as the all_samples_genome.25-35.meanXX_medianYY_reads_concatenated.tab present in the Bam2Reads_genome_output directory. The summary table all_samples_genome.25-35.meanXX_medianYY_reads_concatenated.tab contains for each ORF of the studied category(ies), the number and fraction of reads in its three frames (frame 0 (F0 or P0) and its two alternative frames +1 and +2 (P1/F1 and P2/F2 respectively)). This table has 8 columns: Seq_ID : Identifier of the ORF Num_reads : Number of reads having a P-site aligned on the ORF Num_p0 : Number of reads with their P-site in phase 0 of the ORF Num_p1 : Number of reads with their P-site in phase 1 of the ORF Num_p2 : Number of reads with their P-site in phase 2 of the ORF Perc_p0 : Percentage of reads aligned on the ORF with their P-site in phase 0 (i.e. Num_p0 divided by the total number of reads mapping on the ORF) Perc_p1 : Percentage of reads aligned on the ORF with their P-site in phase 1 Perc_p2 : Percentage of reads aligned on the ORF with their P-site in phase 2 Output folder details : # The dag files which represents the analysis steps with your datasets. The logs/ folder groups together all the error output messages from tools used in ORFribo analysis pipeline. Thus, in the event of an error, it allows you to identify the problematic step (and give us feedback if needed). The RESULTS/ folder contains these files and folders: i) PROJECT_NAME.Analysis_report.txt gathers standard output of each analysis pipeline tool. It allows to know how many reads are present at each step of the analysis : a)raw reads b)reads after trimming and length selection c)after out RNA depletion d)after double alignment on the reference genome. *ii) config.yaml to have a backup of the parameters. *I) Bam2Reads_genome_output/ : Contains the final outputs of the analysis (explained above). *II) annex_database/ : It contains the indexes for the genome alignment and the gff with all CDS named. III) fastqc/ : It contains data quality controls. IV) adapter_lists/ : It contains a text file with the adapters list for each dataset that were found in the config.yaml file or determined from data if the user did not provide any adapter sequence in the configuration file. V) selected_length_tables/ : It contains one subfolder with a file for every threshold the user chose for the alignment on CDSs step (median or mean of P0 proportions) as multiple thresholds may be tried. The file keeps the information of which read length passed the threshold and was kept for the alignment on all ORFs. VI) BAM/ : It contains a BAM file for each dataset (allows visualization on tools such as IGV). VII) no-outRNA/ : It contains fastq files trimmed and after removal of the reads aligned on unwaned sequences. VIII) ORFribo/ : I) Bam2Reads_exome_output/ : It contains one subfolder per kmer (dataset_XYZ_i with i standing for the kmer size) that itsefl contains a table exome.25-35_reads.tab . The information in this table is the same as that contained in the all_samples_genome.25-35.meanXX_medianYY_reads_concatenated.tab table described above but only for the CDSs annotated in the original gff file. Each CDS is associated with the fractions of reads that map on its coding frame (i.e. in-frame reads named also P0 reads) or in its alternative frames. These tables are used for the detection of good quality kmers (Step 2) but can also be used to probe the translation activity of CDSs. In this case, you just need to merge the tables of all retained kmers (the list of the retained kmers can be found in the file /workdir/orfribo/RESULTS/selected_tables/threshold_meanXX_medianXX/dataset_XYZ.txt) into a global table (see here for more details). This final output table will contain for each CDS, the number and fraction of reads mapping in-frame or in the +1 and +2 frames of each CDS. II) database/: It contains the re-formatted fasta and gff with artificial elongated CDSs to avoid the missing of reads which align on the borders of CDSs (i.e. on the start and stop codons). III) annex_database/: It contains the indexes for the exome alignments (alignments on all exons of CDSs as indicated in the original gff file) and the gtf for riboWaltz. IV) BAM_exome/: It contains a BAM file for each dataset corresponding to the alignment on the fasta with transcript by transcript feature. V) riboWaltz/: It contains the P-site offsets file. Particular case of multiple inputs # ORFribo can be launched on multiple datasets (fastqs) as long as the input files concern the same organism - i.e. share the same reference fasta and gff files (more details here ). For this, you just have to put all the fastq files in the /fastq/ folder and launch ORFribo as you usually do with: orfribo CPU MEMORY The output architecture will be the same as the one obtained for a single input, except that all intermediate files will be stored in subdirectories corresponding to each input dataset as follows: orfribo/ \u251c\u2500\u2500 dag_all.svg \u251c\u2500\u2500 dag_last_run.svg \u251c\u2500\u2500 RESULTS/ \u251c\u2500\u2500 config.yaml \u251c\u2500\u2500 adapter_lists/ \u2514\u2500\u2500 one_file_by_sample.txt \u251c\u2500\u2500 Bam2Reads_genome_output/ \u251c\u2500\u2500 all_samples_genome.25-35.mean70_median70_reads_concatenated.tab\" \u2514\u2500\u2500 one_folder_by_sample \u251c\u2500\u2500 concatenated_results_table.tab \u2514\u2500\u2500 one_folder_by_length \u2514\u2500\u2500 Bam2Reads_results_for_all_ORFs_alignment \u251c\u2500\u2500 annex_database/ \u251c\u2500\u2500 gff_files_with_named_CDSs.gff \u251c\u2500\u2500 indexes_for_bowtie2_alignments.bt2 \u251c\u2500\u2500 indexes_for_hisat2_alignments.ht2 \u251c\u2500\u2500 fastqc/ \u251c\u2500\u2500 one_html_by_sample.html \u2514\u2500\u2500 one_zip_by_sample.zip \u251c\u2500\u2500 selected_tables/ \u2514\u2500\u2500 one_folder_by_sample \u251c\u2500\u2500 BAM/ \u251c\u2500\u2500 one_bam_by_sample.bam \u2514\u2500\u2500 one_bai_by_bam.bai \u251c\u2500\u2500 no-outRNA/ \u2514\u2500\u2500 one_file_by_sample.fastq.gz \u2514\u2500\u2500 ORFribo/ \u251c\u2500\u2500 database/ \u251c\u2500\u2500 intermediate_fasta_files.fa \u251c\u2500\u2500 intermediate_gff_files.gff \u251c\u2500\u2500 annex_database/ \u251c\u2500\u2500 intermediate_fasta_files.fa \u251c\u2500\u2500 intermediate_gtf_file_for_riboWaltz.gtf \u251c\u2500\u2500 indexes_for_bowtie2_alignments.bt2 \u2514\u2500\u2500 indexes_for_hisat2_alignments.ht2 \u251c\u2500\u2500 BAM_exome_output/ \u251c\u2500\u2500 one_bam_by_sample.bam \u2514\u2500\u2500 one_bai_by_bam.bai \u251c\u2500\u2500 Bam2Reads_exome_output/ \u2514\u2500\u2500 one_folder_by_sample_and_length \u2514\u2500\u2500 Bam2Reads_results_for_CDS_alignment \u2514\u2500\u2500 riboWaltz/ \u2514\u2500\u2500 riboWaltz's qualitative analysis results \u251c\u2500\u2500 benchmarks/ \u251c\u2500\u2500 one_benchmark_folder_by_rule \u2514\u2500\u2500 one_benchmark_file_by_job \u251c\u2500\u2500 logs/ \u2514\u2500\u2500 one_log_folder_by_rule \u2514\u2500\u2500 one_log_file_by_job_and_command \u251c\u2500\u2500 logsTmp/ \u2514\u2500\u2500 one_file_by_steps_of_interest_for_alignment_stats","title":"Outputs"},{"location":"orfribo_outputs.html#output-folder-architecture-workdirorfribo","text":"Here is the folder architecture of the ORFribo output stored in /workdir/orfribo. The following output example is based on the example provided in the /ORFmine/examples/ directory with the fastq SRR1520313_17031088. /workdir/orfribo/ \u251c\u2500\u2500 dag_all.svg \u251c\u2500\u2500 dag_last_run.svg \u251c\u2500\u2500 RESULTS/ \u251c\u2500\u2500 config.yaml \u251c\u2500\u2500 ORFribo_yeast_example.Analysis_Report.txt \u251c\u2500\u2500 adapter_lists/ \u2514\u2500\u2500 SRR1520313_17031088.txt \u251c\u2500\u2500 Bam2Reads_genome_output/ \u251c\u2500\u2500 all_samples_genome.25-35.mean70_median70_reads_concatenated.tab \u2514\u2500\u2500 SRR1520313_17031088 \u251c\u2500\u2500 genome.25-35.mean70_median70_reads_concatenated.tab \u251c\u2500\u2500 length_25 \u251c\u2500\u2500 genome.25-35.mean70_median70_reads.tab \u251c\u2500\u2500 genome.25-35.mean70_median70_periodicity_all.tab \u251c\u2500\u2500 genome.25-35.mean70_median70_periodicity_start.tab \u2514\u2500\u2500 genome.25-35.mean70_median70_periodicity_stop.tab \u251c\u2500\u2500 length_26 \u251c\u2500\u2500 genome.25-35.mean70_median70_reads.tab \u251c ... \u2514\u2500\u2500 length_35 \u2514\u2500\u2500 genome.25-35.mean70_median70_reads.tab \u251c\u2500\u2500 annex_database/ \u251c\u2500\u2500 NamedCDS_Scer.gff \u251c\u2500\u2500 index_bowtie2.1.bt2 \u251c ... \u251c\u2500\u2500 index_hisat2.1.ht2 \u251c ... \u251c\u2500\u2500 outRNA_bowtie2.1.ht2 \u2514 ... \u251c\u2500\u2500 fastqc/ \u251c\u2500\u2500 SRR1520313_17031088_fastqc.html \u2514\u2500\u2500 SRR1520313_17031088_fastqc.zip \u251c\u2500\u2500 selected_tables/ \u2514\u2500\u2500 threshold_mean70_median70 \u2514\u2500\u2500 SRR1520313_17031088.txt \u251c\u2500\u2500 BAM/ \u251c\u2500\u2500 SRR1520313_17031088.25-35.bam \u2514\u2500\u2500 SRR1520313_17031088.25-35.bam.bai \u251c\u2500\u2500 no-outRNA/ \u2514\u2500\u2500 SRR1520313_17031088.25-35.no-outRNA.fastq.gz \u2514\u2500\u2500 ORFribo/ \u251c\u2500\u2500 database/ \u251c\u2500\u2500 exome.nfasta \u251c\u2500\u2500 exome_elongated.nfasta \u251c\u2500\u2500 exome_elongated.nfasta.fai \u251c\u2500\u2500 exome_elongated.gff \u2514\u2500\u2500 exome_elongated_with_gene_features.gff \u251c\u2500\u2500 annex_database/ \u251c\u2500\u2500 exome_elongated.exons_Scer.fna \u251c\u2500\u2500 exome_elongated.exons_Scer.gff.gtf \u251c\u2500\u2500 exome_elongated.exome_index_bowtie2.1.bt2 \u251c\u2500\u2500 ... \u251c\u2500\u2500 exome_elongated.exome_index_hisat2.1.ht2 \u2514\u2500\u2500 ... \u251c\u2500\u2500 BAM_exome/ \u251c\u2500\u2500 exome_elongated.SRR1520313_17031088.25-35.bam \u2514\u2500\u2500 exome_elongated.SRR1520313_17031088.25-35.bam.bai \u251c\u2500\u2500 Bam2Reads_exome_output/ \u251c\u2500\u2500 SRR1520313_17031088_25 \u251c\u2500\u2500 exome.25-35_reads.tab \u251c\u2500\u2500 exome.25-35_periodicity_all.tab \u251c\u2500\u2500 exome.25-35_periodicity_start.tab \u251c\u2500\u2500 exome.25-35_periodicity_stop.tab \u2514\u2500\u2500 exome.25-35_reads.stats \u251c\u2500\u2500 ... \u2514\u2500\u2500 SRR1520313_17031088_35 \u251c\u2500\u2500 exome.25-35_reads.tab \u251c\u2500\u2500 exome.25-35_periodicity_all.tab \u251c\u2500\u2500 exome.25-35_periodicity_start.tab \u251c\u2500\u2500 exome.25-35_periodicity_stop.tab \u2514\u2500\u2500 exome.25-35_reads.stats \u2514\u2500\u2500 riboWaltz/ \u251c\u2500\u2500 psite_offset.csv \u251c\u2500\u2500 best_offset.txt \u2514\u2500\u2500 exome_elongated.SRR1520313_17031088 \u251c\u2500\u2500 21.tiff \u251c\u2500\u2500 22.tiff \u251c\u2500\u2500 ... \u2514\u2500\u2500 35.tiff \u251c\u2500\u2500 benchmarks/ \u251c\u2500\u2500 adapt_trimming \u2514\u2500\u2500 SRR1520313_17031088.benchmark.txt \u2514\u2500\u2500 ... \u251c\u2500\u2500 logs/ \u251c\u2500\u2500 RiboDoc_package_versions.txt \u251c\u2500\u2500 adapt_trimming \u251c\u2500\u2500 SRR1520313_17031088_cutadapt.log \u2514\u2500\u2500 SRR1520313_17031088_trim_value.log \u2514\u2500\u2500 ... \u2514\u2500\u2500 logsTmp/ \u251c\u2500\u2500 SRR1520313_17031088_adapt_trimming.log \u251c\u2500\u2500 SRR1520313_17031088_bowtie2_run_outRNA.log \u251c\u2500\u2500 SRR1520313_17031088_run_mapping_bowtie2.log \u2514\u2500\u2500 SRR1520313_17031088_run_mapping_hisat2.log","title":"Output folder architecture (/workdir/orfribo/):"},{"location":"orfribo_outputs.html#main-output-table","text":"The main output table can be found in the RESULTS/Bam2Reads_genome_output/ folder and is named all_samples_genome.25-35.meanXX_medianYY_reads_concatenated.tab (with X and Y standing for the median and mean thresholds, here 70 and 70 respectively). This table summarizes the results for each ORF (i.e. numbers and fraction of reads in the three frames of the ORF) calculated for all the retained kmers in each input dataset (in this example, there is only one dataset - SRR1520313_17031088.). If ORFribo has been performed on multiple datasets , it also provides for each dataset a folder named according to the dataset that contains a table with the same format as the all_samples_genome.25-35.meanXX_medianYY_reads_concatenated.tab table but calculated only on the retained kmers of the corresponding dataset dataset_XYZ/genome.25-35.mean70_median70_reads_concatenated.tab . The directories of each dataset also contain the intermediate tables calculated for each retained kmer. The latter are stored in the RESULTS/Bam2Reads_genome_output/dataset_xyz/length_i/ directory where i stands for the kmer sizes. When only one dataset has been provided to ORFribo (as in this example), the output table present in the dataset folder is the same as the all_samples_genome.25-35.meanXX_medianYY_reads_concatenated.tab present in the Bam2Reads_genome_output directory. The summary table all_samples_genome.25-35.meanXX_medianYY_reads_concatenated.tab contains for each ORF of the studied category(ies), the number and fraction of reads in its three frames (frame 0 (F0 or P0) and its two alternative frames +1 and +2 (P1/F1 and P2/F2 respectively)). This table has 8 columns: Seq_ID : Identifier of the ORF Num_reads : Number of reads having a P-site aligned on the ORF Num_p0 : Number of reads with their P-site in phase 0 of the ORF Num_p1 : Number of reads with their P-site in phase 1 of the ORF Num_p2 : Number of reads with their P-site in phase 2 of the ORF Perc_p0 : Percentage of reads aligned on the ORF with their P-site in phase 0 (i.e. Num_p0 divided by the total number of reads mapping on the ORF) Perc_p1 : Percentage of reads aligned on the ORF with their P-site in phase 1 Perc_p2 : Percentage of reads aligned on the ORF with their P-site in phase 2","title":"Main output table"},{"location":"orfribo_outputs.html#output-folder-details","text":"The dag files which represents the analysis steps with your datasets. The logs/ folder groups together all the error output messages from tools used in ORFribo analysis pipeline. Thus, in the event of an error, it allows you to identify the problematic step (and give us feedback if needed). The RESULTS/ folder contains these files and folders: i) PROJECT_NAME.Analysis_report.txt gathers standard output of each analysis pipeline tool. It allows to know how many reads are present at each step of the analysis : a)raw reads b)reads after trimming and length selection c)after out RNA depletion d)after double alignment on the reference genome. *ii) config.yaml to have a backup of the parameters. *I) Bam2Reads_genome_output/ : Contains the final outputs of the analysis (explained above). *II) annex_database/ : It contains the indexes for the genome alignment and the gff with all CDS named. III) fastqc/ : It contains data quality controls. IV) adapter_lists/ : It contains a text file with the adapters list for each dataset that were found in the config.yaml file or determined from data if the user did not provide any adapter sequence in the configuration file. V) selected_length_tables/ : It contains one subfolder with a file for every threshold the user chose for the alignment on CDSs step (median or mean of P0 proportions) as multiple thresholds may be tried. The file keeps the information of which read length passed the threshold and was kept for the alignment on all ORFs. VI) BAM/ : It contains a BAM file for each dataset (allows visualization on tools such as IGV). VII) no-outRNA/ : It contains fastq files trimmed and after removal of the reads aligned on unwaned sequences. VIII) ORFribo/ : I) Bam2Reads_exome_output/ : It contains one subfolder per kmer (dataset_XYZ_i with i standing for the kmer size) that itsefl contains a table exome.25-35_reads.tab . The information in this table is the same as that contained in the all_samples_genome.25-35.meanXX_medianYY_reads_concatenated.tab table described above but only for the CDSs annotated in the original gff file. Each CDS is associated with the fractions of reads that map on its coding frame (i.e. in-frame reads named also P0 reads) or in its alternative frames. These tables are used for the detection of good quality kmers (Step 2) but can also be used to probe the translation activity of CDSs. In this case, you just need to merge the tables of all retained kmers (the list of the retained kmers can be found in the file /workdir/orfribo/RESULTS/selected_tables/threshold_meanXX_medianXX/dataset_XYZ.txt) into a global table (see here for more details). This final output table will contain for each CDS, the number and fraction of reads mapping in-frame or in the +1 and +2 frames of each CDS. II) database/: It contains the re-formatted fasta and gff with artificial elongated CDSs to avoid the missing of reads which align on the borders of CDSs (i.e. on the start and stop codons). III) annex_database/: It contains the indexes for the exome alignments (alignments on all exons of CDSs as indicated in the original gff file) and the gtf for riboWaltz. IV) BAM_exome/: It contains a BAM file for each dataset corresponding to the alignment on the fasta with transcript by transcript feature. V) riboWaltz/: It contains the P-site offsets file.","title":"Output folder details :"},{"location":"orfribo_outputs.html#particular-case-of-multiple-inputs","text":"ORFribo can be launched on multiple datasets (fastqs) as long as the input files concern the same organism - i.e. share the same reference fasta and gff files (more details here ). For this, you just have to put all the fastq files in the /fastq/ folder and launch ORFribo as you usually do with: orfribo CPU MEMORY The output architecture will be the same as the one obtained for a single input, except that all intermediate files will be stored in subdirectories corresponding to each input dataset as follows: orfribo/ \u251c\u2500\u2500 dag_all.svg \u251c\u2500\u2500 dag_last_run.svg \u251c\u2500\u2500 RESULTS/ \u251c\u2500\u2500 config.yaml \u251c\u2500\u2500 adapter_lists/ \u2514\u2500\u2500 one_file_by_sample.txt \u251c\u2500\u2500 Bam2Reads_genome_output/ \u251c\u2500\u2500 all_samples_genome.25-35.mean70_median70_reads_concatenated.tab\" \u2514\u2500\u2500 one_folder_by_sample \u251c\u2500\u2500 concatenated_results_table.tab \u2514\u2500\u2500 one_folder_by_length \u2514\u2500\u2500 Bam2Reads_results_for_all_ORFs_alignment \u251c\u2500\u2500 annex_database/ \u251c\u2500\u2500 gff_files_with_named_CDSs.gff \u251c\u2500\u2500 indexes_for_bowtie2_alignments.bt2 \u251c\u2500\u2500 indexes_for_hisat2_alignments.ht2 \u251c\u2500\u2500 fastqc/ \u251c\u2500\u2500 one_html_by_sample.html \u2514\u2500\u2500 one_zip_by_sample.zip \u251c\u2500\u2500 selected_tables/ \u2514\u2500\u2500 one_folder_by_sample \u251c\u2500\u2500 BAM/ \u251c\u2500\u2500 one_bam_by_sample.bam \u2514\u2500\u2500 one_bai_by_bam.bai \u251c\u2500\u2500 no-outRNA/ \u2514\u2500\u2500 one_file_by_sample.fastq.gz \u2514\u2500\u2500 ORFribo/ \u251c\u2500\u2500 database/ \u251c\u2500\u2500 intermediate_fasta_files.fa \u251c\u2500\u2500 intermediate_gff_files.gff \u251c\u2500\u2500 annex_database/ \u251c\u2500\u2500 intermediate_fasta_files.fa \u251c\u2500\u2500 intermediate_gtf_file_for_riboWaltz.gtf \u251c\u2500\u2500 indexes_for_bowtie2_alignments.bt2 \u2514\u2500\u2500 indexes_for_hisat2_alignments.ht2 \u251c\u2500\u2500 BAM_exome_output/ \u251c\u2500\u2500 one_bam_by_sample.bam \u2514\u2500\u2500 one_bai_by_bam.bai \u251c\u2500\u2500 Bam2Reads_exome_output/ \u2514\u2500\u2500 one_folder_by_sample_and_length \u2514\u2500\u2500 Bam2Reads_results_for_CDS_alignment \u2514\u2500\u2500 riboWaltz/ \u2514\u2500\u2500 riboWaltz's qualitative analysis results \u251c\u2500\u2500 benchmarks/ \u251c\u2500\u2500 one_benchmark_folder_by_rule \u2514\u2500\u2500 one_benchmark_file_by_job \u251c\u2500\u2500 logs/ \u2514\u2500\u2500 one_log_folder_by_rule \u2514\u2500\u2500 one_log_file_by_job_and_command \u251c\u2500\u2500 logsTmp/ \u2514\u2500\u2500 one_file_by_steps_of_interest_for_alignment_stats","title":"Particular case of multiple inputs"},{"location":"orfribo_run.html","text":"Launch the analysis # Be sure that your configuration.yaml file is completed and stored in the /workdir/ directory of the container. Then, from the /workdir/ directory, please type the following command: orfribo CPU_NUMBER MEMORY_AMOUNT Where CPU_NUM is the number of CPU/threads and MEMORY_AMOUNT is the amount of memory (in Giga-Bytes) that can be used for the analysis. Example for 6 CPUs and 12GB memory use: orfribo 6 12 One step of the analysis is done by the riboWaltz tool which can need high RAM resources depending on your data. If the pipeline crashes without any obvious reason, it might be because of a lack of memory available.","title":"Basic run ORFribo"},{"location":"orfribo_run.html#launch-the-analysis","text":"Be sure that your configuration.yaml file is completed and stored in the /workdir/ directory of the container. Then, from the /workdir/ directory, please type the following command: orfribo CPU_NUMBER MEMORY_AMOUNT Where CPU_NUM is the number of CPU/threads and MEMORY_AMOUNT is the amount of memory (in Giga-Bytes) that can be used for the analysis. Example for 6 CPUs and 12GB memory use: orfribo 6 12 One step of the analysis is done by the riboWaltz tool which can need high RAM resources depending on your data. If the pipeline crashes without any obvious reason, it might be because of a lack of memory available.","title":"Launch the analysis"},{"location":"orftrack_annotation.html","text":"ORF annotation # The ORF annotation relies on the comparison of their localization with those of all the genomic features annotated in the initial gff given as input file (e.g. coding sequences (CDS), tRNA, lncRNA, snoRNA, pseudogenes...). ORFs are subsequently assigned as coding (c_CDS) (if they include in the same frame a CDS) or noncoding (nc). Noncoding ORFs are then subdivided into noncoding intergenic ORFs (nc_intergenic) or noncoding overlapping ORFs (nc_ovp-x with x referring to the overlapping genomic feature) (see here for the definition of an overlap). The former correspond to ORFs which do not overlap any genomic feature. The latter consist of ORFs which overlap a non-phased genomic feature (i.e. non coding) on the same or the opposite strand or which overlap a CDS in another frame. Depending on the localization of the overlapping feature (same or opposite strand), the ORFs are annotated as nc_ovp_same-x or nc_ovp_opp-x respectively. Note Notice that the ORFtrack annotation has a particular point of view on the genome which is centered on the identification and annotation of a genome's ORFs rather than the annotation of real biological objets (e.g. tRNA, rRNA or lncRNA for example). ORFtrack looks at the genome with a protein perspective where the ORFs of a genome can be seen as its potential for novel peptides or proteins upon the pervasive translation of their corresponding RNAs. Annotation rules # ORF categories # ORFs can be annotated according to four different categories: (1) c_CDS ORFs which include in the same frame a CDS (2) nc_intergenic ORFs which do not overlap any genomic feature (3) nc_ovp_same-x ORFs which overlap on the same strand, a genetic feature no matter its type (4) nc_ovp_opp-x ORFs which overlap on the opposite strand, a genetic feature no matter its type See examples of each type in Figure 1. Figure 1: representation of the six frames of a DNA section. STOP codons are represented with red stars, CDS with orange boxes and the localization of the non-phased genomic features (e.g. tRNA, lncRNA) are represented with green boxes. Note Notice that a noncoding ORF which overlaps a tRNA is not considered as a tRNA and will not be annotated as tRNA, but rather as an ORF that overlaps a tRNA. Indeed a tRNA is a RNA molecule that does not follow the ORF definition (not bounded by STOP codons, whose sequence length is not necessarily a multiple of 3...). Here ORFs are seen as potential peptides or proteins that could be produced upon the pervasive translation of their corresponding RNA. Annotating all ORFs with the genomic feature they overlap enables their analysis in a very flexible fashion. Indeed, the user can adopt different levels of annotation, considering all noncoding ORFs as a whole (i.e. regardless of the fact they overlap a genomic feature or not) or differentiating noncoding ORFs from noncoding ORFs that overlap specific genomic features (e.g. tRNA and rRNA) (see the ORFget section for more details). Priority rules # If a noncoding ORF overlaps multiple genomic features, it will be annotated according to the following priority rules: if the noncoding ORF overlaps a CDS and another annotated feature, the CDS has priority over the other annotated features no matter the CDS is located on the same or the opposite strand. The ORF will be annotated as a noncoding ORF overlapping a CDS (e.g. nc_ovp_(same/opp)-CDS). if the noncoding ORF overlaps an annotated feature on the same strand and another annotated feature on the opposite strand (except CDS), the annotated feature located on the same strand has priority over the other features on the opposite strand. The ORF will be annotated as a noncoding ORF overlapping the feature on the same strand (e.g. nc_ovp_same-x). if the noncoding ORF overlaps multiple annotated features located on the same strand, the feature with the larger overlap with the ORF to be annotated has priority over the other features (e.g. nc_ovp_(same/opp)-x). if the noncoding ORF overlaps multiple features located on the same strand and that cover the same fraction of the ORF to be annotated, the feature which first appears in the GFF file has priority over the others. This case occurs with large annotated features that embed smaller elements. Particular case of genes and exons. Notice that many genomic features overlap together or can be intertwined with each other (e.g. a gene includes one or several mRNAs which in turn include exons and CDS). By default, the features \"gene\" and \"exon\" are not considered. ORFs that match at the same time with the features \"gene\" and \"mRNA\" are annotated as nc_(same/opp)_ovp-mRNA (see Figure 2), while those that match with a CDS and its corresponding exon, will be annotated as c_CDS (i.e. coding ORFs). Finally, noncoding ORFs that overlap in another frame a CDS, and an exon will be annotated as nc_(same/opp)_ovp-CDS. Figure 2: representation of the three frames of a DNA strand section containing a protein coding gene. STOP codons are represented with red stars, the two CDS of the multiexonic gene with orange boxes, while the protein coding gene and its corresponding mRNA are represented with light and dark grey boxes respectively. The two ORFs indicated with brackets do not overlap the CDS of the gene and are subsequently annotated as noncoding. However, they overlap the gene and its corresponding mRNA. As the mRNA has priority over the gene feature, the two ORFs are annotated as noncoding ORF overlapping a mRNA (nc_ovp_same-mRNA).","title":"ORF annotation"},{"location":"orftrack_annotation.html#orf-annotation","text":"The ORF annotation relies on the comparison of their localization with those of all the genomic features annotated in the initial gff given as input file (e.g. coding sequences (CDS), tRNA, lncRNA, snoRNA, pseudogenes...). ORFs are subsequently assigned as coding (c_CDS) (if they include in the same frame a CDS) or noncoding (nc). Noncoding ORFs are then subdivided into noncoding intergenic ORFs (nc_intergenic) or noncoding overlapping ORFs (nc_ovp-x with x referring to the overlapping genomic feature) (see here for the definition of an overlap). The former correspond to ORFs which do not overlap any genomic feature. The latter consist of ORFs which overlap a non-phased genomic feature (i.e. non coding) on the same or the opposite strand or which overlap a CDS in another frame. Depending on the localization of the overlapping feature (same or opposite strand), the ORFs are annotated as nc_ovp_same-x or nc_ovp_opp-x respectively. Note Notice that the ORFtrack annotation has a particular point of view on the genome which is centered on the identification and annotation of a genome's ORFs rather than the annotation of real biological objets (e.g. tRNA, rRNA or lncRNA for example). ORFtrack looks at the genome with a protein perspective where the ORFs of a genome can be seen as its potential for novel peptides or proteins upon the pervasive translation of their corresponding RNAs.","title":"ORF annotation"},{"location":"orftrack_annotation.html#annotation-rules","text":"","title":"Annotation rules"},{"location":"orftrack_annotation.html#orf-categories","text":"ORFs can be annotated according to four different categories: (1) c_CDS ORFs which include in the same frame a CDS (2) nc_intergenic ORFs which do not overlap any genomic feature (3) nc_ovp_same-x ORFs which overlap on the same strand, a genetic feature no matter its type (4) nc_ovp_opp-x ORFs which overlap on the opposite strand, a genetic feature no matter its type See examples of each type in Figure 1. Figure 1: representation of the six frames of a DNA section. STOP codons are represented with red stars, CDS with orange boxes and the localization of the non-phased genomic features (e.g. tRNA, lncRNA) are represented with green boxes. Note Notice that a noncoding ORF which overlaps a tRNA is not considered as a tRNA and will not be annotated as tRNA, but rather as an ORF that overlaps a tRNA. Indeed a tRNA is a RNA molecule that does not follow the ORF definition (not bounded by STOP codons, whose sequence length is not necessarily a multiple of 3...). Here ORFs are seen as potential peptides or proteins that could be produced upon the pervasive translation of their corresponding RNA. Annotating all ORFs with the genomic feature they overlap enables their analysis in a very flexible fashion. Indeed, the user can adopt different levels of annotation, considering all noncoding ORFs as a whole (i.e. regardless of the fact they overlap a genomic feature or not) or differentiating noncoding ORFs from noncoding ORFs that overlap specific genomic features (e.g. tRNA and rRNA) (see the ORFget section for more details).","title":"ORF categories"},{"location":"orftrack_annotation.html#priority-rules","text":"If a noncoding ORF overlaps multiple genomic features, it will be annotated according to the following priority rules: if the noncoding ORF overlaps a CDS and another annotated feature, the CDS has priority over the other annotated features no matter the CDS is located on the same or the opposite strand. The ORF will be annotated as a noncoding ORF overlapping a CDS (e.g. nc_ovp_(same/opp)-CDS). if the noncoding ORF overlaps an annotated feature on the same strand and another annotated feature on the opposite strand (except CDS), the annotated feature located on the same strand has priority over the other features on the opposite strand. The ORF will be annotated as a noncoding ORF overlapping the feature on the same strand (e.g. nc_ovp_same-x). if the noncoding ORF overlaps multiple annotated features located on the same strand, the feature with the larger overlap with the ORF to be annotated has priority over the other features (e.g. nc_ovp_(same/opp)-x). if the noncoding ORF overlaps multiple features located on the same strand and that cover the same fraction of the ORF to be annotated, the feature which first appears in the GFF file has priority over the others. This case occurs with large annotated features that embed smaller elements. Particular case of genes and exons. Notice that many genomic features overlap together or can be intertwined with each other (e.g. a gene includes one or several mRNAs which in turn include exons and CDS). By default, the features \"gene\" and \"exon\" are not considered. ORFs that match at the same time with the features \"gene\" and \"mRNA\" are annotated as nc_(same/opp)_ovp-mRNA (see Figure 2), while those that match with a CDS and its corresponding exon, will be annotated as c_CDS (i.e. coding ORFs). Finally, noncoding ORFs that overlap in another frame a CDS, and an exon will be annotated as nc_(same/opp)_ovp-CDS. Figure 2: representation of the three frames of a DNA strand section containing a protein coding gene. STOP codons are represented with red stars, the two CDS of the multiexonic gene with orange boxes, while the protein coding gene and its corresponding mRNA are represented with light and dark grey boxes respectively. The two ORFs indicated with brackets do not overlap the CDS of the gene and are subsequently annotated as noncoding. However, they overlap the gene and its corresponding mRNA. As the mRNA has priority over the gene feature, the two ORFs are annotated as noncoding ORF overlapping a mRNA (nc_ovp_same-mRNA).","title":"Priority rules"},{"location":"orftrack_description.html","text":"Aims and general description # ORFtrack scans a given genome in the six frames, and searches for all possible ORFs longer than a given size (default: 60 nucleotides - STOP codons excluded). It annotates them according to a set of genomic features (e.g. noncoding intergenic, coding, noncoding and overlapping with a specific genomic feature - see the ORF annotation section for more details). ORFtrack takes as inputs a fasta file containing the nucleotide sequences of all chromosomes or contigs and their corresponding annotations in a gff file. The program returns a new gff file that contains all identified ORFs. In addition, the amino acid sequences of all annotated ORFs or specific subsets of ORFs (i.e. only noncoding intergenic ORFs for example) can be extracted and written in a fasta file with ORFget, a tool provided with ORFtrack.","title":"Aims and general description"},{"location":"orftrack_description.html#aims-and-general-description","text":"ORFtrack scans a given genome in the six frames, and searches for all possible ORFs longer than a given size (default: 60 nucleotides - STOP codons excluded). It annotates them according to a set of genomic features (e.g. noncoding intergenic, coding, noncoding and overlapping with a specific genomic feature - see the ORF annotation section for more details). ORFtrack takes as inputs a fasta file containing the nucleotide sequences of all chromosomes or contigs and their corresponding annotations in a gff file. The program returns a new gff file that contains all identified ORFs. In addition, the amino acid sequences of all annotated ORFs or specific subsets of ORFs (i.e. only noncoding intergenic ORFs for example) can be extracted and written in a fasta file with ORFget, a tool provided with ORFtrack.","title":"Aims and general description"},{"location":"orftrack_input.html","text":"ORFtrack inputs # ORFtrack takes as inputs: a fasta file containing the nucleotide sequences of the chromosomes or contigs of a genome the genome annotation in a gff file (see the GFF3 documentation for more details on the gff3 format). These files must be stored together in a local directory that will be linked to the /database/ directory of the container (see here for more details). See an example of inputs in the ORFmine/examples/database directory.","title":"Inputs"},{"location":"orftrack_input.html#orftrack-inputs","text":"ORFtrack takes as inputs: a fasta file containing the nucleotide sequences of the chromosomes or contigs of a genome the genome annotation in a gff file (see the GFF3 documentation for more details on the gff3 format). These files must be stored together in a local directory that will be linked to the /database/ directory of the container (see here for more details). See an example of inputs in the ORFmine/examples/database directory.","title":"ORFtrack inputs"},{"location":"orftrack_orf_extraction.html","text":"ORF extraction # The amino acid and nucleotide sequences of all ORFs identified with ORFtrack can be extracted easily with ORFget, a tool provided with ORFtrack. Particularly, ORFget enables the user to extract the sequences of all identified ORFs (c_CDS, noncoding intergenic, or noncoding overlapping ORFs), but also, those of a specific ORF category (e.g. only noncoding intergenic ORFs) or a combination of ORFs according to their annotations (e.g. noncoding intergenic ORFs and noncoding ORFs that overlap lncRNAs...). Different examples are detailed in the ORFget section .","title":"ORF extraction"},{"location":"orftrack_orf_extraction.html#orf-extraction","text":"The amino acid and nucleotide sequences of all ORFs identified with ORFtrack can be extracted easily with ORFget, a tool provided with ORFtrack. Particularly, ORFget enables the user to extract the sequences of all identified ORFs (c_CDS, noncoding intergenic, or noncoding overlapping ORFs), but also, those of a specific ORF category (e.g. only noncoding intergenic ORFs) or a combination of ORFs according to their annotations (e.g. noncoding intergenic ORFs and noncoding ORFs that overlap lncRNAs...). Different examples are detailed in the ORFget section .","title":"ORF extraction"},{"location":"orftrack_orfdef.html","text":"ORF definition # ORFs are defined according to the recent definition proposed by Sieber et al, in 2018. An ORF: has a length divisible by 3 is bounded by stop codons is at least 60 nucleotides long (STOP codons excluded) The minimal length of an ORF can be nevertheless modified by the user with the -orf_len parameter (notice that the ORF length does not include the STOP codons). The following instruction extracts all ORFs of at least 100 amino acids: orftrack -fna /database/genome.fasta -gff /database/genome.gff -orf_len 300","title":"ORF definition"},{"location":"orftrack_orfdef.html#orf-definition","text":"ORFs are defined according to the recent definition proposed by Sieber et al, in 2018. An ORF: has a length divisible by 3 is bounded by stop codons is at least 60 nucleotides long (STOP codons excluded) The minimal length of an ORF can be nevertheless modified by the user with the -orf_len parameter (notice that the ORF length does not include the STOP codons). The following instruction extracts all ORFs of at least 100 amino acids: orftrack -fna /database/genome.fasta -gff /database/genome.gff -orf_len 300","title":"ORF definition"},{"location":"orftrack_overlap.html","text":"Overlap definition # Calculation of the overlap: An ORF is considered as overlapping a given genomic feature if the latter covers at least 70% of the ORF sequence. If less than 70% of an ORF sequence overlaps a genomic feature, but the latter is totally included in the ORF sequence, then the ORF is also considered as overlapping it. Notice that the overlap threshold can be modified with the -co_ovp parameter. With the following instruction, an ORF is annotated as overlapping a given genomic feature if the latter covers at least 90% of the considered ORF. orftrack -fna /database/genome.fasta -gff /database/genome.gff -co_ovp 0.90","title":"Overlap definition"},{"location":"orftrack_overlap.html#overlap-definition","text":"Calculation of the overlap: An ORF is considered as overlapping a given genomic feature if the latter covers at least 70% of the ORF sequence. If less than 70% of an ORF sequence overlaps a genomic feature, but the latter is totally included in the ORF sequence, then the ORF is also considered as overlapping it. Notice that the overlap threshold can be modified with the -co_ovp parameter. With the following instruction, an ORF is annotated as overlapping a given genomic feature if the latter covers at least 90% of the considered ORF. orftrack -fna /database/genome.fasta -gff /database/genome.gff -co_ovp 0.90","title":"Overlap definition"},{"location":"orftrack_param.html","text":"ORFtrack parameters # Mandatory -fna nucleotide fasta file of the genome whose ORFs are to annotate -gff gff annotation file Optional -h, --help shows the help and exits --show-types prints all genomic features annotated in the input gff file --show-chrs prints all the seqID (usually corresponding to chromosome or contig ID) present in the input gff file -chr list of seqID to be treated by ORFtrack (i.e. column #1 of the gff file - generally chromosome or contig ID). ID must be separated by a space: -chr NC_001148.4 NC_001139.3 In this case, ORFtrack will not treat the entire genome, but the following seqID NC_001148.4 NC_001139.3. We recommend using this option when dealing with large genomes in order to distribute the calculations on several CPUs (one per (subset of) seqID). -orf_len Minimal number of nucleotides between two consecutive STOP codons to define an ORF (default: 60 nucleotides) (see the ORF definition section for more details). -co_ovp Minimal fraction of the ORF length that overlaps a genomic feature to annotate the ORF as overlapping it (default: 0.70). (see the Overlap section for more details). -types_only Genomic feature(s) considered for the annotation step ('CDS' is included by default). If there are several genomic features to be considered, they must be given separated by a space. Noncoding ORFs are annotated as intergenic (when they do not overlap any feature) or overlapping (when they overlap a given genomic feature). The \"overlapping\" status directly derives from the genomic features considered for the annotation step. For example, if the user specifies with the \"types_only\" option, the features \"tRNA\" and \"rRNA\" (CDS are included by default), all ORFs that overlap another genomic feature (i.e. different from tRNA, rRNA, or CDS) will be annotated as noncoding intergenic ORFs. If no genomic feature is indicated, noncoding ORFs that overlap any genomic feature annotated in the original gff file will be annotated as noncoding ORF overlapping the corresponding genomic feature. Nevertheless, the resulting ORFs can be treated specifically (grouped according to their annotation for example) with ORFget afterwards (see the ORFget section for more details). -types_except Genomic feature(s) not to be considered for the annotation step ('gene' and 'exon' not considered by default). If there are several genomic features to be considered, they must be given separated by a space. Noncoding ORFs are annotated as intergenic (when they do not overlap any feature) or overlapping (when they overlap a given genomic feature). The \"overlapping\" status directly derives from the genomic features considered for the annotation step. For example, when specifying with the \"types_except\" option, the features \"telomer\" and \"centromer\" ('gene' and 'exon' not considered by default), if an ORF overlaps a \"telomer\", \"centromer\", \"gene\" and/or \"exon\", the overlap will not be considered and the ORF will be annotated as intergenic or overalapping another genomic feature if there is another genomic feature in the same region (e.g. an ORF that overlaps at the same time a gene and a tRNA will be annotated as overlapping a tRNA since the gene is not considered for the ORF annotation). If no genomic feature is indicated, noncoding ORFs that overlap any genomic feature annotated in the original gff file will be annotated as noncoding ORF overlapping the corresponding genomic feature. Nevertheless, the resulting ORFs can be treated specifically (grouped according to their annotation for example) with ORFget afterwards (see the ORFget section for more details).","title":"ORFtrack parameters"},{"location":"orftrack_param.html#orftrack-parameters","text":"Mandatory -fna nucleotide fasta file of the genome whose ORFs are to annotate -gff gff annotation file Optional -h, --help shows the help and exits --show-types prints all genomic features annotated in the input gff file --show-chrs prints all the seqID (usually corresponding to chromosome or contig ID) present in the input gff file -chr list of seqID to be treated by ORFtrack (i.e. column #1 of the gff file - generally chromosome or contig ID). ID must be separated by a space: -chr NC_001148.4 NC_001139.3 In this case, ORFtrack will not treat the entire genome, but the following seqID NC_001148.4 NC_001139.3. We recommend using this option when dealing with large genomes in order to distribute the calculations on several CPUs (one per (subset of) seqID). -orf_len Minimal number of nucleotides between two consecutive STOP codons to define an ORF (default: 60 nucleotides) (see the ORF definition section for more details). -co_ovp Minimal fraction of the ORF length that overlaps a genomic feature to annotate the ORF as overlapping it (default: 0.70). (see the Overlap section for more details). -types_only Genomic feature(s) considered for the annotation step ('CDS' is included by default). If there are several genomic features to be considered, they must be given separated by a space. Noncoding ORFs are annotated as intergenic (when they do not overlap any feature) or overlapping (when they overlap a given genomic feature). The \"overlapping\" status directly derives from the genomic features considered for the annotation step. For example, if the user specifies with the \"types_only\" option, the features \"tRNA\" and \"rRNA\" (CDS are included by default), all ORFs that overlap another genomic feature (i.e. different from tRNA, rRNA, or CDS) will be annotated as noncoding intergenic ORFs. If no genomic feature is indicated, noncoding ORFs that overlap any genomic feature annotated in the original gff file will be annotated as noncoding ORF overlapping the corresponding genomic feature. Nevertheless, the resulting ORFs can be treated specifically (grouped according to their annotation for example) with ORFget afterwards (see the ORFget section for more details). -types_except Genomic feature(s) not to be considered for the annotation step ('gene' and 'exon' not considered by default). If there are several genomic features to be considered, they must be given separated by a space. Noncoding ORFs are annotated as intergenic (when they do not overlap any feature) or overlapping (when they overlap a given genomic feature). The \"overlapping\" status directly derives from the genomic features considered for the annotation step. For example, when specifying with the \"types_except\" option, the features \"telomer\" and \"centromer\" ('gene' and 'exon' not considered by default), if an ORF overlaps a \"telomer\", \"centromer\", \"gene\" and/or \"exon\", the overlap will not be considered and the ORF will be annotated as intergenic or overalapping another genomic feature if there is another genomic feature in the same region (e.g. an ORF that overlaps at the same time a gene and a tRNA will be annotated as overlapping a tRNA since the gene is not considered for the ORF annotation). If no genomic feature is indicated, noncoding ORFs that overlap any genomic feature annotated in the original gff file will be annotated as noncoding ORF overlapping the corresponding genomic feature. Nevertheless, the resulting ORFs can be treated specifically (grouped according to their annotation for example) with ORFget afterwards (see the ORFget section for more details).","title":"ORFtrack parameters"},{"location":"orftrack_run.html","text":"Annotation of ORFs with ORFtrack # Running ORFtrack on a complete genome # The following instruction annotates all the possible ORFs of the input genome. orftrack -fna /database/genome.fasta -gff /database/genome.gff Depending on the size of the genome, ORFtrack takes a few minutes to several hours to annotate all the ORFs of a genome. It returns a new gff file containing the annotation of all the identified ORFs (including coding and noncoding ORFs). The output gff file is stored in the /database/ folder of the container and named mapping_orf_[genome].gff. It also provides a summary.log file that summarizes for each chromosome/contig all the ORF categories that have been detected. Running ORFtrack on a single chromosome or a subset of chromosomes # ORFtrack can be launched on a single seqID (usually chromosome or contig indicated in the first column of the input gff)(e.g. chromosome seqID: XXX) with the following instruction: orftrack -fna /database/genome.fasta -gff /database/genome.gff -chr chr_ID_XXXX This can be very useful if the user wants to run ORFtrack on several CPUs. Also, it can be launched on a subset of seqIDs as follows: orftrack -fna /database/genome.fasta -gff /database/genome.gff -chr seqID1 seqID2 seqIDx","title":"ORF annotation with ORFtrack"},{"location":"orftrack_run.html#annotation-of-orfs-with-orftrack","text":"","title":"Annotation of ORFs with ORFtrack"},{"location":"orftrack_run.html#running-orftrack-on-a-complete-genome","text":"The following instruction annotates all the possible ORFs of the input genome. orftrack -fna /database/genome.fasta -gff /database/genome.gff Depending on the size of the genome, ORFtrack takes a few minutes to several hours to annotate all the ORFs of a genome. It returns a new gff file containing the annotation of all the identified ORFs (including coding and noncoding ORFs). The output gff file is stored in the /database/ folder of the container and named mapping_orf_[genome].gff. It also provides a summary.log file that summarizes for each chromosome/contig all the ORF categories that have been detected.","title":"Running ORFtrack on a complete genome"},{"location":"orftrack_run.html#running-orftrack-on-a-single-chromosome-or-a-subset-of-chromosomes","text":"ORFtrack can be launched on a single seqID (usually chromosome or contig indicated in the first column of the input gff)(e.g. chromosome seqID: XXX) with the following instruction: orftrack -fna /database/genome.fasta -gff /database/genome.gff -chr chr_ID_XXXX This can be very useful if the user wants to run ORFtrack on several CPUs. Also, it can be launched on a subset of seqIDs as follows: orftrack -fna /database/genome.fasta -gff /database/genome.gff -chr seqID1 seqID2 seqIDx","title":"Running ORFtrack on a single chromosome or a subset of chromosomes"},{"location":"parameters_orfold.html","text":"ORFfold parameters # Mandatory -faa fasta file containing the amino acid sequences to treat -options indicates which properties are to be calculated. H for estimating the fold potential with HCA, I for the estimation of the disorder propensity with IUPred and T for the aggregation propensity with Tango. Combinations of letters are accepted if the user wants to calculate several properties at the same time (-options HIT will estimate the three properties)(default: H). Optional -h, --help shows this help message and exits -gff gff annotation file. The ID (i.e. annotation) of the sequences given in the input FASTA file sequence must be identical to the ID label in the gff file (column #3). ORFold generates as many gff files as studied properties (fold potential, disorder and/or aggregation propensities), each containing for the sequences provided in the input fasta file, their corresponding property values (fold potential, disorder or aggregation propensities). The values are stored in the column #9 of the output gff files that can be subsequently uploaded on a genome viewer (see here examples on the use of this option). -keep ORFold uses IUPred and Tango for the prediction of the disorder and aggregation propensities. For storage reasons, by default, ORFold does not save the output files of these two methods. Nevertheless, the user can keep the Tango output files through the option -keep . -keep T will save Tango output files in the TANGO directory. -N Working with large genomes can eventually generate quite big files. For that reason, ORFold has also the option to generate a sample of the initial dataset and perform the calculation only on this specific subset of the population. This option enables the user to indicate the number of randomly selected sequences to be treated by ORFold.","title":"ORFold parameters"},{"location":"parameters_orfold.html#orffold-parameters","text":"Mandatory -faa fasta file containing the amino acid sequences to treat -options indicates which properties are to be calculated. H for estimating the fold potential with HCA, I for the estimation of the disorder propensity with IUPred and T for the aggregation propensity with Tango. Combinations of letters are accepted if the user wants to calculate several properties at the same time (-options HIT will estimate the three properties)(default: H). Optional -h, --help shows this help message and exits -gff gff annotation file. The ID (i.e. annotation) of the sequences given in the input FASTA file sequence must be identical to the ID label in the gff file (column #3). ORFold generates as many gff files as studied properties (fold potential, disorder and/or aggregation propensities), each containing for the sequences provided in the input fasta file, their corresponding property values (fold potential, disorder or aggregation propensities). The values are stored in the column #9 of the output gff files that can be subsequently uploaded on a genome viewer (see here examples on the use of this option). -keep ORFold uses IUPred and Tango for the prediction of the disorder and aggregation propensities. For storage reasons, by default, ORFold does not save the output files of these two methods. Nevertheless, the user can keep the Tango output files through the option -keep . -keep T will save Tango output files in the TANGO directory. -N Working with large genomes can eventually generate quite big files. For that reason, ORFold has also the option to generate a sample of the initial dataset and perform the calculation only on this specific subset of the population. This option enables the user to indicate the number of randomly selected sequences to be treated by ORFold.","title":"ORFfold parameters"},{"location":"parameters_orfplot.html","text":"ORFplot parameters # Mandatory -tab one or several tables produced by ORFold containing the fold potential of each table entry. For each given table, ORFplot plots the distribution of the fold potential of all the table entries. ORFplot will plot as many distributions as given tables. Optional -h, --help shows this help message and exits -names names of each input dataset to write in the legend. If the names consist of several words, please indicate them enclosed in double quotes, -names \"Noncoding sequences (all)\" \"Noncoding sequences translated in condition X\"","title":"ORFplot parameters"},{"location":"parameters_orfplot.html#orfplot-parameters","text":"Mandatory -tab one or several tables produced by ORFold containing the fold potential of each table entry. For each given table, ORFplot plots the distribution of the fold potential of all the table entries. ORFplot will plot as many distributions as given tables. Optional -h, --help shows this help message and exits -names names of each input dataset to write in the legend. If the names consist of several words, please indicate them enclosed in double quotes, -names \"Noncoding sequences (all)\" \"Noncoding sequences translated in condition X\"","title":"ORFplot parameters"},{"location":"virtualenv.html","text":"Virtual environment #","title":"Virtualenv"},{"location":"virtualenv.html#virtual-environment","text":"","title":"Virtual environment"}]}